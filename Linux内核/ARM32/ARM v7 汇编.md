## Arm v7汇编笔记

本文主要关于armv7处理器模式和寄存器相关知识。

### ARM处理器模式和寄存器

#### 早期ARM处理器模式

在ARMv6之前，未引入安全扩展模式，那时一共有七种处理器模式。其中六种为特权模式，一种非特权用户模式。特权模式下可以执行一些非特权用户模式不可以执行的工作。在用户模式下，关于影响整个系统的配置操作是受限的。这七种模式如下所示：

| 模式              | 功能                                          | 特权       |
| :---------------- | :-------------------------------------------- | :--------- |
| 用户模式（USR）   | 大部分程序和应用运行的模式                    | 非特权模式 |
| FIQ               | 进入一个FIQ中断异常                           | 特权模式   |
| IRQ               | 进入一个IRQ中断异常                           | 特权模式   |
| 监管者模式（SVC） | 复位或当一个监管者调用指令（SVC）被执行时进入 | 特权模式   |
| 中止（ABT）       | 进入一个内存访问异常                          | 特权模式   |
| 未定义（UND）     | 当一个未定义指令被执行时进入                  | 特权模式   |
| 系统模式（SYS）   | OS运行时得模式，和用户模式共享寄存器          | 特权模式   |

#### ARMV7架构模式

  由于信任区扩展的引入，从而为处理器特权和进程模式创建了两个安全状态，并且一个新的监管者模式来切换安全和非安全状态。每个安全状态的存在模式相互独立。如下所示：
![[mk.att/Pasted image 20220314111230.png]]

  ARMv7-A架构的虚拟扩展在已存在特权模式外添加了一个管理程序模式（Hyp），虚拟化可以使超过一个操作系统同时存在或操作相同系统。如下图所示：

![[mk.att/Pasted image 20220314111246.png]]

  如果实现了虚拟化扩展，再非安全模式下有三种特权等级，PL0,PL1,PL2.

> PL0
> 应用软件的特权等级，在用户模式下执行。在用户模式下执行的软件被认为为非特权软件。这种软件不能访问架构的一些特性。特别是他不能改变大部分配置。在PL0执行的软件仅可以执行非特权内存访问。
> PL1
> 在除了用户模式和Hyp模式外的所有模式中执行的软件都位于PL1，通常操作系统软件在PL1执行。一个操作系统通常执行于整个PL1，它的应用在PL0执行。
> PL2
> Hyp模式通常被虚拟层使用，它控制并可以切换在PL1执行的客户操作系统。如果虚拟扩展被实施，虚拟层将在PL2(Hyp模式)执行。一个虚拟层管理将会控制并使能多个操作系统在同一个处理器系统中共存和执行。

特权模式如下所示：
![[mk.att/Pasted image 20220314111312.png]]

在通用操作系统上，例如linux和它的应用都被期望运行于非安全状态。安全状态一般被生产商指定固件或安全敏感软件运行。在这种情况下，运行于安全状态的软件比运行于非安全状态的软件更有特权。目前处理器模式和执行状态包含在目前程序状态寄存器（CPSR）中。改变处理器状态和模式可以通过特权软件明确指定或通过相关部分的异常链接来实现。

#### 寄存器

  ARM架构为软件提供16个32位通用目的寄存器（R0-R15）。其中15个（R0到R14）被用于通用目的数据存储。R15为程序计数器，指向内核执行指令地址。软件明确写到R15的值可以更改程序流程。软件也可以访问CPSR和之前执行模式CPSR的副本（SPSR）。

![[mk.att/Pasted image 20220314111336.png]]

  一个寄存器可能对应于不同的物理存储地址，它被称为banking。他们使用物理地址不同的存储并且通常仅在一个进程在特定模式执行时可被访问。

![[mk.att/Pasted image 20220314111344.png]]

R13为堆栈指针。R14保存子程序的返回地址。R15为程序计数器，并保存目前的程序地址（实际上，它总是比ARM状态下的当前指令提前8个字节，比Thumb状态下的当前指令提前4个字节），当R15在ARM状态下被读取时，位[1:0]为0，位[31:2]包含PC，在Thumb状态下，位[0]总是读为0。

##### 程序状态寄存器

  在任何时刻，你都可以访问16个寄存器（R0-R15）和目前程序状态寄存器（CPSR）。在用户模式，一个被称为应用程序状态寄存器（APSR）的限制格式CPSR被作为替代访问。

目前程序状态寄存器（CPSR）被用于存储：

- APSR标志
- 目前处理器模式
- 中断使能标志
- 目前处理器状态：ARM,Thumb,ThumbEE,或Jazelle
- 字节顺序
- IT块的执行状态位

  应用程序必须使用APSR来访问CPSR中可以在非特权模式改变的部分。APSR仅可用于访问N,Z,C,V,Q和GE[3:0]位。这些位不能直接访问，但可以通过条件代码设置指令来设置或通过条件执行指令来测试。
  例如，CMP R0,R1指令来比较R0和R1的值，并在R0等于R1时设置Z。

下图展示了CPSR的位分配：

![[mk.att/Pasted image 20220314111359.png]]

每个位的意义如下：

- N - ALU结果为负
- Z - ALU结果为0
- C - ALU操作进位，即加法运算中，无符号运算发生溢出为1，否则为0。减法运算中发生借位则为0，否则为1。对于包含移位操作的非加减法运算，C中包含最后一次溢出的位的数值。
- V - ALU操作溢出，当操作数和运算结果为二进制表示的带符号数时，V=1表示符号位溢出。
- Q - 累计饱和（也被称为粘性）
- J - 表示内核是否位于Jazelle状态。
- GE[3:0] - 被一些SIME指令使用
- IT[7:2] - Thumb-2指令组中If-Then指令的执行
- E位用于控制加载和存储字节顺序
- A位用于禁用异步中止。
- I位禁用IRQ
- F位禁用FIQ
- T位 - 表示内核是否位于Thumb状态
- M[4:0] - 指定处理器模式（FIQ,IRQ…）

**内核可以使用直接写CPSR模式位的指令来改变模式。通常，处理器根据异常事件结果来自动改变模式。在用户模式不能操作PSR的位[4:0]来控制进程模式或A,I,F位来控制异常的使能。**

一旦设定了CPSR.M，ARM处理器就会将processor mode切换到对应mode。

| 处理器模式 | 缩写 | 对应的M[4:0]编码 | Privilege level |
| ---------- | ---- | ---------------- | --------------- |
| User       | usr  | 10000            | PL0             |
| FIQ        | fiq  | 10001            | PL1             |
| IRQ        | irq  | 10010            | PL1             |
| Supervisor | svc  | 10011            | PL1             |
| Monitor    | mon  | 10110            | PL1             |
| Abort      | abt  | 10111            | PL1             |
| Hyp        | hyp  | 11010            | PL2             |
| Undefined  | und  | 11011            | PL1             |
| System     | sys  | 11111            | PL1             |

##### 协处理器 cp15

CP15， 系统控制协处理器，提供内核许多特性的控制。它可以包含16个32位主要寄存器。对CP15的访问是特权控制，并且并不是所有的寄存器在用户模式都有效。CP15中的16个主要寄存器名字为c0到c15，但是通常使用名字引用，例如CP15的系统控制寄存器被称为CP15.SCTLR。

  所有系统架构函数可以通过从协处理器15的寄存器集（CRn）读取到通用处理器寄存器（Rt）或从通用处理器寄存器读取到协处理器寄存器集来控制协处理器。指令的Op1,Op2,和CRm字段也可以被用于选择寄存器或操作，格式如下所示：

```
MRC p15, Op1, Rt, CRn, CRm, Op2 ;       读取一个CP15寄存器到ARM寄存器
MCR p15, Op1, Rt, CRn, CRm, Op2 ;       从一个ARM寄存器读取到CP15寄存器
```

汇编语言通常是低级程序语言。它通常和二进制操作码指令一一对应。学习汇编语言可以方便我们更好理解芯片运行过程与操作。

### ARM指令集

  ARMv7架构是一个32位处理器架构，它也是一个加载/存储架构。这意味着数据指令只能在通用目的寄存器上操作。尽管ARMv7架构是一个32位架构，但是单个处理器实现并不需要对所有块都为32位宽连接。例如，它可以位64位或更宽的指令访问与数据获取。

  大部分ARM处理器支持两个甚至三个不同指令集。一般ARM处理器可以使用最少两种指令集。

ARM(32位指令)

> 这是原ARM指令集

Thumb

> Thumb指令集在ARM7TDMI处理器中被首次添加。并且仅包含16位指令（它使得在嵌入式中程序更小）。目前的处理器，大部分支持Thumb-2技术，这个技术将Thumb指令集扩展为提供一个16位和32位指令的混合。它融合了两个指令集的有点，既能像ARM指令集那样执行，代码的尺寸又像Thumb指令那么小。

  当执行一个Thumb指令，PC读取目前指令地址加四。能修改PC的16位Thumb指令只有MOV和ADD。写到PC的值被强制通过忽略最小有效位来半字对齐。

  目前使用的指令集通过CPSR T位来表示。当T=0时核心位于ARM状态，T=1时核心位于Thumb状态。

  对于Thumb汇编，通常有一个16位和32位指令编码选择。.W(32位)和.N(16位)可以被用于强制编码为特定编码。例如：

```
BCS.W   label       ;强制32位指令，即使是一个短的分支
B.N     label       ;如果标签超出16位指令范围则异常
```

### GUN编译器

  我们可以通过运行arm-none-eabi-as程序来编译ARM汇编语言源文件的内容。

```
arm-none-eabi-as -g -o filename.o filename.s
```

选项-g需要编译器在输出文件中包含debug信息。当所有的源文件都被编译为二进制对象文件后，我们可以使用GUN链接器来创建ELF格式的可执行文件。

```
arm-none-eabi-ld -o filename.elf filename.o
```

  我们也可以使用arm-none-eabi-gdb或arm-none-eabi-insight提供的调试器来在自己主机系统上运行这个可执行文件。

#### GUN汇编程序语法

  汇编语言源文件每一行包含一条语句。每个语句有三个可选项组成，顺序如下所示：

```
label: instruction @ comment
```

  label可以用于标识这个指令的地址。它后面可以被用于分支指令的目标或用于加载和存储指令。
  instruction可以为一个ARM汇编指令或一个汇编指令。它们可以为伪指令来告诉汇编程序去做一些事或来控制段和对齐，或创建数据。

  在@符号后面的部分被作为注释。

#### 段

  一个可执行程序代码至少有一个段，通常被称为.text，数据被包含在.data段。
  相同名字的指令使能够指定这两个部分中哪一个应该包含源文件接下来内容。可执行代码应该出现在一个.text段，可读或可写数据位于.data段。只读内容位于.rodata段。未初始化数据位于.bss。符号(bss)部分起始的块定义了未初始化静态数据的空间。

#### 汇编程序指令

所有的汇编指令都以’.’为起始。下面为一些通用指令。

.align

>  这使汇编程序在数据段以0值来填充二进制。或在代码段以NOP指令填充代码，以确保下一个位置位于一个字边界。.align n在ARM内核表示2^n对齐。
>  .ascii “string”
>  在目标文件中准确插入指定字符串。这个字符串不以NULL终止。多个字符串可以使用逗号作为分割。
>  .asciiz
> 功能和.ascii相同。但是字符尾部跟随一个NULL字符。
> .byte expression, .hword expression, .word expression
> 插入一个字节，半字或字到目标文件。多个值可以使用逗号作为分隔符来指定。同义词.2byte和.4byte功能一样。
> .data
> 将接下来的内容放到最后可执行文件的数据段。
> .end
> 标志这个源代码文件的结尾。在这个位置后面汇编程序不再执行文件中的任何内容。
> .equ symbol,expression
> 设置symbol的值为expression。“=”符号和.set有着同样效果。
> .extern symbol
> 表示symbol定义在其它源代码文件。
> .global symbol
> 告诉编译器symbol对于所有源文件和链接器全局有效。
> .include “filename”
> 插入filename的内容到目前源文件，通常用于包含含有共享定义的头文件。
> .text
> 它将接下来的内容的目的转变为最终输出对象文件的代码段。汇编指令必须总是位于代码段。

  下表列出了GNU和ARM工具的通用汇编指令。并没有列出全部，并且它们也并不是完全一致。

![image-20220307092341061](C:/Users/casey.EE/AppData/Roaming/Typora/typora-user-images/image-20220307092341061.png)

#### GUN工具命名惯例

  寄存器在GCC中命名如下：

- 通用寄存器：R0-R15
- 堆栈指针寄存器：SP(R13)
- 栈指针寄存器FP(R11)
- 链接寄存器：LR(R14)
- 程序计数器：PC(R15)
- 程序状态寄存器标志：xPSR,xPSR_all,xPSR_f,xPSR_x,xPSR_ctl,xPSR_fs,xPSR_fx,xPSR_f,xPSR_cs,xPSR_cf,xPSR_cx(当x=C时表示目前，S表示保存的)。

### ARM工具汇编语言

ARM工具现在使用Unified Assembly Language(UAL)格式来使能ARM和Thumb指令集使用相同标准语法。UAL拥有写出可以在所有ARM内核上运行的汇编代码能力。在过去，必须为ARM或Thumb状态显式地编写代码。使用UAL可以在汇编时为不同的指令集汇编相同的代码，而不是在编写代码时。这可以通过使用命令行开关或内联指令来实现。遗留代码仍将正确地组装。值得注意的是，GNU汇编器现在通过使用.syntax指令支持UAL，尽管它可能与ARM工具汇编器的语法不完全相同。

#### ARM汇编语法

ARM汇编程序源文件每一行包含一条语句，每个语句有三个可选项，如下所示：

```
label instruction ; comment
```

一个label用于标识指令的地址。

#### Directives

定义常量（DCD,DCB,DCW）指令可以将数据放到一块代码中。例如：

```
MESSAGE DCB "Hello World!",0
```

这将会生成一个对应于ASCII码的字符串，并以0结尾。MESSAGE为一个标签，我们可以获取这个数据的地址。

EQU指令可以让你给地址或数据值分配一个名字。例如：

```
CtrlD EQU 4
TUBE EQU 0x30000000
```

然后就可以在其它指令中使用这些名字，来作为表达式的一部分来计算。类似于C语言中的#define。

### 数据处理操作

  ARM内核仅支持在寄存器上的数据操作。并不能直接处理内存上的。数据处理指令使用一个目的寄存器和两个源操作数。格式大致如下所示：

```
Operation{cond}{S} Rd, Rn, Operand2
```

### 内存指令

ARM内核仅可以在寄存器上操作算术逻辑单元（ALU），仅支持的内存操作为load(把数据从内存读到寄存器)或store(将数据从寄存器写到内存)。可通过LDR和STR指令来实现。

#### 地址模式

有多种地址模式被用于加载和存储数据：

- 寄存器寻址——地址位于一个寄存器中。（1）
- Pre-indexed addressing——在内存访问前给基址添加一个偏移量。基本格式为：LDR Rd, [Rn, Op2]。偏移量可以为正数或负数。并且可以为立即数或带有偏移的另一个寄存器的值。（2，3）
- Pre-indexed with write-back——通过在指令后添加感叹号来表示。在内存访问发生后，它通过添加偏移量来更新基址。（4）
- Post-index with write-back——偏移值在寻址后被写回。仅用基址来进行内存访问。访问完成后将将偏移地址加到基址上。（5）

```
(1) LDR         R0, [R1]                    @取R1指向地址的数据
(2) LDR         R0, [R1, R2]                @取R1+R2指向地址的数据
(1) LDR         R0, [R1, R2, LSL #2]        @取R1 + (R2*4)指向地址的数据
(1) LDR         R0, [R1, #32]!              @取R1+32指向地址的数据,然后R1:=R1+32
(1) LDR         R0, [R1], #32               @取R1指向地址的数据,然后R1:=R1+32
```

#### 多重传输

加载和存储多条指令可以使能连续数据从内存读或写。这对于堆栈操作或内存复制很有用。并且这种操作以字为单位，并且地址需要字对齐。操作数是一个基本寄存器(一个可选的!表示回写基寄存器)，括号之间的寄存器列表。寄存器列表用逗号分隔，用连字符表示范围。寄存器加载或存储的顺序与列表中指定的顺序无关。相反，操作以固定的方式进行，最低编号的寄存器总是映射到最低地址。

例如：

```
LDMIA       R10!, { R0-R3, R12 }
```

这个指令从R10指向的地址读取五个寄存器，由于回写被指定，最后将R10的值增加20（5 x 4bytes）。

  这个指令也必须指定从基础寄存器Rd的哪里开始。有四种可能：IA/IB(在之后/之前递增)与DA/DB(在之后/之前递减)。它们也可以通过变体（FD,FA,ED,EA）来指定。这些变体从堆栈角度出发，并指定堆栈指针指向堆栈的满定还是空顶，以及堆栈在内存中是向上增长还是向下。
  通常基于ARM处理器的系统中堆栈仅使用满顶向下（FD）选项。这意味着堆栈指针指向堆栈内存中最后一个已填充的位置，并且在新的数据放到堆栈中时将会降低地址。

例如：

```
STMFD   sp!, {r0-r5}    ;入栈到一个满顶向下栈
LDMFD   sp!, {r0-r5}    ;从一个满顶向下栈出栈
```

入栈操作如图所示：

### 分支

  这个指令集提供许多不同类型分支指令，对于简单的相对分支（相对于目前地址的分支），可以使用B指令。当调用子程序时，子程序需要将返回地址存放到链接寄存器，应使用BL指令。
  如果你想要改变指令集（从ARM到Thumb或Thumb到ARM），使用BX,或BLX。
  你也可以指定PC作为普通数据执行操作（ADD或SUB）的目的寄存器，但是他一般被弃用，并且Thumb并不支持这个操作。一个额外类型的分支指令可以通过使用加载（LDR）指令，并以PC作为目的寄存器。或加载多个（LDM）或出栈（POP）指令，并将PC作为一系列寄存器中的一个来加载。
  Thumb有比较和分支指令，它融合了CMP指令和一个条件分支，但是并不会改变CPSR条件代码标志。它有两个操作码，CBZ（如果Rn为0，跳转到label）和CBNZ(如果Rn不为0则跳转到label)，这些指令只能在4到130个字节间跳转。

### 饱和运算

饱和运算通常被用于音频或视频编解码。如果运算时返回一个比最大正数大或比最小负数小的数时，它并不会溢出，而是结果被替换为最大正数或最小负数。ARM指令集包含一些指令来使能这个算法。

#### 饱和运算指令

  ARM饱和算术指令可以在字节，字或半字上操作，例如QADD8和QSUB8中的8表示他们在字节上操作。操作的结果将会饱和于最大可能正数或最小可能负数。如果结果将要溢出或已经饱和，溢出标志（CPSR中的Q位）被置位。这个标志位被称为黏着的。一旦这个位被置位，在明确通过向CPSR写来清除它前，它会一直保留。
  这个指令集使用专门的指令：QSUB和QADD，另外QDSUB和QDADD提供对于Q15或Q31定点运算的支持。这些指令在执行特定加或减前会使他们的第二个操作数加倍并饱和。
  前导零计数（CLZ）指令返回有效位前的0的数量，这对于统一化或对于特定除法算法很有用。要将一个值饱和到特定的位置(实际上饱和到2的幂)，可以使用USAT或SSAT(无符号或有符号)饱和操作。USAT16和SSAT16允许在寄存器内填充两个半字值。

### 混杂指令

  其余指令包括协处理器，监管者调用，PSR修改，字节倒置，页预加载，位操作和一些其它的。

#### 协处理指令

  协处理器指令占据了部分ARM指令集，我们可以应用多达16个协处理器，从0到15（CP0,CP1,…CP15）,他们可以为内部（建立在处理器里）或通过一个特定接口外部连接的。外部协处理器在老版本处理器中不常见，并且不被Cortex-A系列支持。

- 协处理器15为内置协处理器，它用于提供许多内核特性包含cache和MMU。
- 协处理器14为内置协处理器，它用于控制内核的硬件debug功能，例如断点单元。
- 协处理器10和11用于提供系统中的浮点和NEON硬件访问。

  如果一个协处理器指令被执行，但是对应的协处理器并不在系统中，则未定义指令异常将会发生。

  关于协处理器指令有5个类：

- CDP——启动协处理器数据操作
- MRC——将数据从协处理器寄存器移动到ARM寄存器
- MCR——将数据从ARM寄存器移动到协处理器
- LDC——从内存中加载协处理器寄存器
- STC——将协处理器寄存器存储到内存

这些指令的多寄存器操作和其他变体如下：

- MRRC——将一个值从协处理器转移到一对ARM寄存器
- MCCR——将一对ARM寄存器转移到一个协处理器
- LDCL——从多个寄存器读取一个协处理器寄存器
- STCL——将一个协处理器寄存器写到多个寄存器

#### SVC

  SVC(监管调用)指令，当被执行时将导致一个管理员调用异常。这个指令包含一个24位（ARM）或8位（Thumb）值。它可以被SVC异常处理代码检测到。通过SVC机制，一个操作系统可以指令一系列应用在用户模式请求的特权操作。这个指令源于SWI（软件中断）。

#### PSR修改

  有几个指令使能PSR被写入或读取：

- MRS将CPSR或SPSR值放到一个通用目的寄存器。MSR将一个通用目的寄存器的值写入CPSR或SPSR。整个状态寄存器或其中的一部分可以被更改。在用户模式下，所有位都可以被读，但是只有条件标志（_f）可以被更改。
- 在特权模式下，改变处理器状态（CPS）指令可以被用于直接修改模式和CPSR中的中断使能或使不能（I和F）位。
- SETEND修改单个CPSR位（E（Endian）位）。它可以被用于使用混合字节序的系统来临时在大端和小端数据访问间切换。

### 位操作

  下面指令用于使能寄存器中的值的位操作：

- 位字段插入（BFI）指令可以从一个寄存器底部通过指定位宽和LSB位置来将一系列相邻位放到该寄存器任一位置。
- 位字段清除（BFC）指令可以清除一个寄存器中相邻位。
- SBFX和UBFX指令（有符号和无符号位字段提取）复制相邻位从一个寄存器到第二个寄存器的最小有效位。并且符号位扩展或0扩展该值到32位。
- RBIT指令反转一个寄存器中的所有位的顺序。

#### cache预加载

  页预加载提供了两个指令：PLD(数据页预加载)和PLI(指令页预加载)。两个指令行为都类似于提示内存系统一个对于特定地址的访问将会马上发生。不支持这些操作的实施方式将会将预加载看为NOP，任何对PLD参数指定的不合法的地址不会被作为一个数据抛弃异常来处理。

#### 字节翻转

  翻转字节顺序的指令在处理对立字节序或其他数据预排序操作中很有用。

- REV指令翻转一个字中的字节
- REV16翻转一个寄存器中每个半字的字节。
- REVSH翻转底部两个字节，符号将结果扩展为32位。

#### 其他指令

  一些其他有效指令：

- 断点指令（BKPT）将会造成一个预取异常或造成内核进入debug状态（取决于处理器配置为监管者模式还是停止模式debug。）这个指令被调试者使用。
- 等待中断（WFI）使内核进入standby模式，内核在被一个中断或调试事件唤醒前停止执行。**如果在中断使不能情况下执行了WFI，一个中断仍然可以唤醒内核，但是不会产生中断异常。内核在WFI后继续执行。在老的ARM寄存器中，WFI作为一个CP15操作来实施。**
- NOP将会会执行任何东西，它并不能保证会花费时间来执行，所以不能使用NOP指令来作为代码的时间延时。它用于填充。
- 等待事件（WFE）指令使内核进入到standby模式，内核将会睡眠到另一个内核执行一个REV指令产生一个事件。一个中断或bug事件也会唤醒内核。
- SEV(发送事件)指令被用于产生唤醒事件，来唤醒群里的其他内核。

### 跳转指令(branch)

- 无条件跳转
	- B
	- BAL

```c
B LABEL;   LABEL为某个位置
```

- 条件跳转
	- BEQ 相等
	- BNE 不等
	- BPL 非负
	- BMI 负
	- BCC 无进位
	- BCS 有进位
	- BLO 小于（无符号）
	- BHS 大于等于（无符号）
	- BVC 无溢出（有符号）
	- BVS 有溢出（有符号）
	- BGT 大于（有符号）
	- BGE 大于等于（有符号）
	- BLT 小于（有符号）
	- BLE 小于等于（有符号）

```c
bl Xm    @ 跳转到由Xm目标寄存器指定的地址处，同时将下一条指令存放到lr中
b Xm     @ 跳转到由Xm目标寄存器指定的地址处，不需要返回
ret {Xm}  @ 跳转到由Xm目标寄存器指定的地址处，一般不写Xm，默认跳转到lr处
```
