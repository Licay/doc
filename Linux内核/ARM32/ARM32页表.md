## ARM32页表

>
>本文翻译自
>https://people.kernel.org/linusw/arm32-page-tables
>

本文主要解释了页表相关的内核基本概念，以及它是如何在ARM32平台上实现的。

为了理解启动分页，我们需要重复和扩展一些Linux分页术语。一些好的背景知识可以阅读Gormans在他的书《理解Linux虚拟内存管理器》中对Linux页表的描述。本书于2007年出版，基于梅尔2003年的博士论文。从那以后的13年里发生了一些事情，但基本情况仍然没有改变。这需要去了解页表中的新层，例如Linux内核中使用的五层页表。

首先是入门：带有经典MMU的ARM32架构具有2级页表，最新的LPAE（大型物理地址扩展）MMU具有3级页表。

一些ARMv7架构具有LPAE，并且能够条件启用，也就是说，如果机器愿意，它们也可以使用经典的MMU，它们两者都具有。这并没有在默认的*multi_v7*配置中启用：你的机器必须在编译时显式地打开它。因为层次的不同，以至于同一个二进制镜像永远无法同时支持classic/LPAE MMU。

ARMv7-A的早期实现（如Cortex A8和 Cortex A9）不支持LPAE，更确切地说是在此架构的生命周期内引入的。这是一个编译配置项，所以在缺省时ARMv7的默认配置不会启用它，否则会破坏旧的实现。ARMv8在缺省时都启用LPAE。

但是，让我们先讨论Linux如何看待分页的世界。

### Linux内核的页表视图

页表在Linux内核的通用分页管理机制中看起来是这样的：

![[mk.att/Pasted image 20220908150228.png]]

*Linux 内核中的抽象页表从 PGD (全局页目录)到 P4D (第四级目录)、 PUD (上层页目录)、 PMD (中间页目录) ，再到实际的页表项(PTE) ，这些条目将内存的各个页从虚拟地址空间映射到物理地址空间。*

缩写：

- **pgd**, pgd_t, pgdval_t = **Page Global Directory （全局页目录）** – PGD内核内存的主页表句柄见 Linux kernel 符号`swapper_pg_dir`

- **p4d**, p4d_t, p4dval_t = **Page Level 4 Directory （第4页目录）** 在 pud 引入之后，引入了处理5级页表的功能。现在可以看到，需要使用一个能够指示目录级别的符号来替代pgd\pmd\pud，不能再使用惯用语。这不在ARM32中使用。

- **pud**, pud_t, pudval_t = **Page Upper Direcory （上层页目录）** 是在其他抽象符号之后引入的，用于处理4级页表。和p4d一样，这不在ARM32中使用。

- **pmd**, pmd_t, pmdval_t = **Page Middle Directory （中间页目录）**，ARM32会使用这个。

- **pte**, pte_t, pteval_t = **Page Table Entry （页表项）**，ARM32会使用这个。

- **pfn** = **Page Frame Number （页帧号）**，物理内存中的每一页都有一个唯一的编号、地址`0x00000000`是第0页，地址`0x00001000`是第1页等 (见[`include/asm-generic/memory_model.h`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/asm-generic/memory_model.h))。

首先也是最重要的一点是，除了PTE之外，它们都被命名为*something-directory*。这是因为它们都包含几个指向下一级对象的指针。和其他目录一样。所以每个 PGD，P4D... 等实体都是指针数组。尽管 PTE 具有单数形式，但它也包含几个指针。

内核能够运行在拥有5级页表的设备上。对于ARM32来说，这当然是过度设计的，因为 ARM32有2或3级页表，但是我们需要迎合世界其他地方的需求。通用设计。实际上，代码的组织使得这些页表可以“折叠”，并且在可能的情况下，我们通常会跳过中间的翻译步骤。

关于页表层次结构，你需要了解的另一件事是，在最低级别上，PTE包含许多指针，这些指针是1到1的转换块。在 ARM32上，在PTE级别上，每个PTE总是有512个指针，每个指针转换一个4KB（1页，0x1000）的内存。

![[mk.att/Pasted image 20220908154921.png]]

*ARM32上的PTE包含512个指针，即物理页和虚拟页之间的转换。从通用的内核虚拟内存管理的角度来看，这种转换如何在硬件中实际发生并不重要，它需要知道的只是一个大小为0x1000(4KB)的页面是由一个 PTE 指针条目转换的。这样，PTE就是一个目录，就像页面层次结构中的其他所有内容一样。在本例中，PTE中的第一个指针将物理地址0x10000000转换为虚拟地址0xC0000000。*

在PMD级别上，经典的ARM32 MMU每PMD有一个指针，每PGD有2048个指针。P4D和PUD层级是“折叠”的，即未使用。每个PMD只有一个指针似乎有点无意义。您完全可以问，为什么要有一个“三级”层次结构，其中间目录每个PMD有一个指针。**这是一种将Linux关于页面层次结构的想法与实际的ARM32架构相结合的方法**，稍后将对此进行解释。

![[mk.att/Pasted image 20220908160214.png]]

*Linux中的经典ARM32分页设置折叠P4D和PUD，每个PGD项提供2048个指针，每个PMD项提供1个指针，每个PTE项提供512个指针。它使用3级的层次结构，而ARM32硬件只有2级。然而，我们将看到，这是一个很好的选择。左边是对象关系，右边是对应的说明。*

在LPAE上，情况要简单得多: 每个PGD有4个指针，每个指针覆盖1GB(总共4GB的内存) ，每个PMD有512个指针，将每个1GB划分为2MB的块，然后每个PTE有512个指针，将2 MB的块划分为4kb的块(页)。数据应该吻合。LPAE MMU当然可以将更多的指针放入PGD中，以覆盖多达1TB的内存。目前没有ARM32架构需要这个，所以我们只是把它压缩到内核空间的最大4GB。4GB的内核空间内存应该足够每个人使用了。用户空间就是另一回事了。

![[mk.att/Pasted image 20220908163258.png]]

*LPAE页表也可以折叠P4D和PUD，但是在PMD级别上有一些有意义的东西:4个PGD条目，每个1GB，覆盖整个32位地址空间，然后每个PMD有512个指针，每个PTE有512个指针。每个PTE条目将4KB的物理内存转换为虚拟内存。如果我们将所有512个可用条目填满PGD，它将正好跨越1TB的内存。*

因此，当我们说经典的ARM32 MMU有两个层次的页表时，我们用一种特殊的方式将其呈现给Linux，即“3个层次”，其中中间一个是一个单指针，而LPAE MMU实际上有3个层次。我们很抱歉造成了混乱。

### 获取指向目录项的指针

指向目录中索引的指针是通过特殊的内联函数获得的，这些接口接受一个虚拟地址作为参数，例如`pmd_off()`，这些内联函数穿过整个层次结构以获得层次结构中正确元素的偏移量:

```c
static inline pmd_t *pmd_off(struct mm_struct *mm, unsigned long va)
{
	return pmd_offset(pud_offset(p4d_offset(pgd_offset(mm, va), va), va), va);
}
```

在 ARM32上，这个层级的P4D和PUD部分将设置为零，进行“折叠”，并在编译时优化出来。`struct mm_struct *mm`参数是实际的内存管理上下文(对于内核来说是`init_mm`) ，它存储的指针指向全局页目录(PGD)实际驻留的内存。如果我们正在运行内核代码，那么它将是`swapper_pg_dir`。这就是在 include/linux/pgtable.h 中实际发生的情况;

```c
#define pgd_offset(mm, address)         pgd_offset_pgd((mm)->pgd, (address))

(...)

static inline pgd_t *pgd_offset_pgd(pgd_t *pgd, unsigned long address)
{
        return (pgd + pgd_index(address));
};
```

在内核空间中，`mm`参数为`init_mm`而`->pgd`指针指向`swapper_pg_dir`，这是内核内存空间根页表，等于实际物理全局页表在虚拟内存中的位置。所有的索引指针访问器都按照这个原则操作。

### ARM32的页表视图

内核空间全局页面目录的虚拟地址是`PAGE_OFFSET+0x3000`或`PAGE_OFFSET+0x4000`，而`PAGE_OFFSET`依赖于内核 VMSPLIT，但通常是`0xC0000000`，即内核内存为`0xC0000000..0xFFFFFFFF`。在 ARM32上，物理内存中的这个基地址在**TTBR0**(转换表基础寄存器)中设置。Linux 对这个地址使用符号`swapper_pg_dir`标识。LPAE 的大小为`0x5000`字节，经典的 ARM MMU 的大小为`0x4000`字节。如果内核从物理地址`0xnnnn8000`开始，那么它的物理地址是`0xnnnn8000-PG_DIR_SIZE`，所以`0xnnnn3000..0xnnndemoFFF`表示 LPAE ，而`0xnnnn4000..0xnnndemoFFF`为任何其他 ARM。最常见的位置是`0xC0004000..0xC0007FFF`在虚拟内存中。

PTE 页表条目和相关类型`pte_t`和`pteval_t`当然纯粹是 Linux 概念。看得出来。因为ARM32 MMU考虑的不是PTE，而是4KB页的2级或3级粗页表。如果Linux被设计成一种更灵活的方式，允许一个粗页表为**ONE PTE**，那将是非常简洁的，但并不总是这样，对于老的ARM32系统，情况肯定不是这样。

在这个上下文中，“粗糙”意味着我们从1级描述符开始，看到对于这1MB的虚拟内存，我们正在使用一些较小的4K页，因此我们必须进一步观察:使用我在这里给出的修改后的虚拟地址，在页面表层级上运行。ARM MMU还有一个细页表的概念，只有1K。Linux暂时不使用这些。

我们在这里处理`PAGE_SIZE`粗粒度，Linux 内存管理器期望每个PTE是一个大的页面，并且有很多指针，因此我们将调用`arm_pte_alloc()`来分配一个新的2级(或LPAE上的3级)页表，该表的大小为`0x1000`(4096)字节。这很简单。

在LPAE系统中，情况也相当简单，因为PTE实际上占用1页，它由512个64位/8字节的条目填充，这意味着我们有`512 * 8 = 4096`字节，这是一个完美的匹配。而且这64位满足了Linux内存管理器和提供某些MMU工具(比如“dirty”位)的体系结构之间的契约。LPAE MMU上的一个PTE是一个包含这些粗糙的第三级描述符的页表(请记住，LPAE有三个级别的页表)。在ARM64/Aarch64平台上也是如此。

困难的是Linux如何在经典的老式ARM MMU上利用这些4096字节，这在 include/asm/pgtable-2level.h 中进行了描述。

在经典MMU上所做的是将过程页表索引放入级别1描述符的修改后的虚拟地址(MVA)字段中。这个“粗页表索引”位于级别1描述符的10-31位(这是半个PGD条目，稍后再详述) ，它对应于级别2页表物理地址的最高21位。过程页表索引的特殊之处在于它不对应于内存中的页。相反，它相当于四分之一页。这是合乎逻辑的，因为2级页表是32位/4字节，我们需要256个页表来覆盖1MB，这是1级描述符的颗粒度，因此我们需要`256 * 4 = 1024 = 0x400`字节。这是4KB页的四分之一。因此，粗页表索引指向虚拟内存中由`0x400:th`块索引的位置。这有点让人困惑。

此外，我们还有以下问题:ARM经典MMU没有"dirty"和"accessed"/"young"位，而通用的Linux虚拟内存管理器预先假定在架构中存在这些。

可以想象，告诉Linux虚拟内存管理器，每个PTE只有256个指针，在其余部分中放入一些元数据，但最终只使用了半个页面，并且因为PTE浪费了大量内存。

在ARM32上的实际解决方案(我认为这是Russell King发明的)是尽可能多地挤进一个页，如下所示:

- 告诉 Linux 虚拟内存管理器，我们有512个页描述符，Linux 称之为 PTE 中的“指针”，尽管我们非常清楚硬件有256个页描述符。这是通过设置`PTRS_PER_PTE` 为512，在[`include/asm/pgtable-2level.h`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm/include/asm/pgtable-2level.h)

- 告诉它，我们在PMD中映射了2MB的内存。这是通过定义`PMD_SHIFT`为21完成的，在  `include/asm/pgtable-2level.h`。尽管事实上我们非常清楚1级描述符映射的是1MB 而不是2MB 的内存，但仍然可以做到这一点。我们还将中间页目录(PMD)设置为1对1的目录，每个 PMD 只有一个指针:设置`PTRS_PER_PMD` 为1。

- 设置`__PAGETABLE_PMD_FOLDED`为1，所以我们不为PMD分配任何实际的后台数据结构，因为这些数据结构将存储在 PGD 中。

- 告诉它 PGD 包含2048个指针(设置`PTRS_PER_PGD`为2048)，而事实上每个1级描述符占用`0x4000`字节，其中包含了4096个指针，我们将它们成对分组。

- 每当通用内存管理器请求一个 PGD 条目时，我们就引用由两个1级页表描述符组成的 PMD 指针。

- 每当通用内存管理器请求一个 PMD 条目时，我们就会引用一个1对1的条目。

- 每当通用内存管理器请求一个 PTE 条目时，我们就会引用两个2级页表描述符和两个32-bit长度的元数据条目。

然后，我们用这两组二级描述符占用半页。为了解决不同"dirty"和"accessed"/"young"位的映射问题，我们使用剩下的半页来保存一些关于 Linux 请求的元数据，这样我们就可以对 Linux 虚拟内存管理器想要的特性进行一些前后模拟。

我们已经有效地向内核虚拟内存管理器提出，我们有一个带有三层页表的 MMU: PGD (2048个指针)、 PMD (一个指针)和 PTE (512个指针) ，而实际上我们的硬件只有两层页表，然后在通用虚拟内存管理器的后台我们通过这种优化来调整映射到实际硬件。

这并没有那么糟糕: 虚拟内存管理器很清楚，并不是全世界都使用它所支持的五个级别的页表，因此它已经被编写为“折叠”级别，就像我们修改的 PMD 一样。这样就行了。

唉，这不是个简单的解决方案。但它非常有效，虽然违反直觉且复杂。由于操作系统开发在细节方面可能相当困难，这是我们可以期待的。

![[mk.att/Pasted image 20220909111427.png]]

*经典的 ARM32 MMU 页表布局在两个层次上使用32位描述符: 全局页表(TTB，Linux 称之为 PGD，全局页目录)中的两个一级描述符组成为一个 PMD (中间页目录)。有4096个1级描述符，两两组成一个 PMD，因此有2048个 PMD。（**每个1级描述符指向0x400内存，其中包含256个2级描述符**）然后，由256 + 256 = 512个2级描述符组成一个 PTE (页表项) ，其上面有一些元数据。Linux 看到的是每个PMD管理2MB内存，而每个PTE管理512 x 4KB，也是2MB内存。（**意思是PMD和PTE是1：1对应的，因为ARM32只有2级页表**）每个PTE 只占用1页内存(见图示，512 x 2 x 4 = 4KB) ，这样事情就简单多了。1级描述符被称为“粗页表”。*

![[mk.att/Pasted image 20220909142902.png]]

*在经典的 ARM32 MMU 中使用的32位 Level-1和 Level-2页描述符的粗略格式，这是大多数 ARM32 Linux 内核使用的。“粗页” 1级描述符指向“小页”(4KB)页描述符。可以看到，在每个级别上覆盖的内存区域是通过简单地使用 MMU 中常见的物理地址的高位来映射的。一些域和访问控制填充在剩余的位中，显式设置为0或1的位应该是这样的。* `定义在arch/arm/include/asm/pgtable-2level.h`

另一方面，LPAE 页表设置比传统的 MMU 更简单、更深入: 描述符为64位宽，包含 Linux 所需的所有位。通常地址`0xC0003000`指向4个64位的1级描述符（PGD），其覆盖前4GB 物理内存(`0x00000000-0xFFFFFFFF`) ；地址`0xC0004000`指向512个2级描述符（PMD），它们是64位的，但每个指针覆盖2MB，所以它们覆盖的虚拟内存空间与经典 MMU 相同: 不是用1024个32位“粗页”条目覆盖每个1MB，而是512个64位条目覆盖每个2MB。这使得1个PGD 指针对应于1个1级页描述符，1个PMD 指针对应于1个2级页描述符。

2级描述符指向3级描述符，这些描述符都是64位宽，覆盖4KB内存。在第三个级别上，512个描述符覆盖2 MB内存，正好占用一个4KB 的内存页面。此外，第3级描述符中的描述符布局非常符合 Linux 需要的特殊位，比如“dirty”, “young” 和 “accessed”。PGD、 PMD 和 PTE 在硬件方面有着相同的概念，这使得它们更加直观。ARM64/Aarch64也使用这种页面描述符样式。

![[mk.att/Pasted image 20220909145949.png]]

*与经典的 MMU 相比，LPAE 页表布局更简单、更直观。在三个级别上都使用64位描述符，其中每个描述符对应于一个 PGD、 PMD 或 PTE 条目，图示使用在`0xC0003000`上连续的4个 PGD 描述符，分别指向`0xC0004000`,`0xC0005000`,`0xC006000`和`0xC0007000`；一个 PMD 包含512个64位描述符；一个 PTE 包含512个64位描述符（转换指针），正好占用1页(0x1000字节)。*
