## Arm32 调度和内核边界

### 关于任务（task）

对于任务（task），我们通常指的是用户进程、用户线程和内核线程。内核调度器认为它们之间没有重大区别，它们是存在于特定 CPU 上的可调度实体。

内核线程是最容易理解的：在作为内核的大型计算机程序中，不同的线程代表内核执行管理。它们都由一个名为 kthreadd 的特殊线程实例化，即内核线程守护进程。它们的存在有多种用途，一个是提供进程上下文来中断线程，另一个是运行工作队列，例如延迟工作等。例如，内核驱动程序能够将执行移交给可以在后台进行改动的进程上下文，这很方便。

用户空间中的进程实质上是执行计算机程序，或者按照旧术语来说是执行对象，这给出了如“目标文件格式”等表达方式的来源。内核将启动很少的此类进程，但 modprobe 和 init（其进程 ID 总是为 1）是例外。任何其他用户空间进程都由 init 启动。进程可以fork新进程，也可以在自身内部创建单独的执行线程，这些线程也将成为可调度的实体，因此某个进程（执行的计算机程序）本身可以具有并发性。POSIX 线程通常是这种情况的实现方式，并且存在进一步的抽象，例如 GLib、GThread 等。

![[mk.att/Pasted image 20240605162555.png]]

> 使用 CGFreak 生成的某个系统上根据优先级分配的任务饼图显示，从调度器的角度来看，只有任务，任何内核线程或从进程生成的线程都只是成为可调度的任务实体。

**用户空间**是我们执行进程的特定执行上下文的常用名称。定义这种环境的是它有自己的内存上下文，一个唯一的 MMU 表，在 ARM32 的情况下，它为每个进程提供了一个巨大的虚拟内存。它的执行与内核和其他进程隔离，但**不与它自己的线程（通常是 POSIX 线程）隔离**。要与内核或其他用户空间进程进行通信，它需要使用系统调用“syscall”或发出、接收信号。这两种机制都是作为软件中断实现的。（要与自己的生成线程进行通信，可以使用快捷方式）

相反，**内核空间**是操作系统执行的上下文，在我们的例子中是 Linux。它有自己的内存上下文（MMU 表），但部分内核内存通常也可以被用户空间进程访问（mmap等手段），并且内核线程共享虚拟内存空间，因此异常可以直接跳转到虚拟内存中的内核代码中，内核可以直接读写到用户空间内存中。这样做是为了促进内核和用户空间之间的快速通信。在 Linux 的体系结构中，在内核空间中执行与提升机器权限相关联，这意味着**操作系统可以发出某些特权指令或以其他方式访问某些受限资源**。MMU table 权限可保护内核代码不被用户空间进程检查或覆盖。

### 异常事件

让我们回顾一下 ARM32 异常。

异常向量表，它是从 0xFFFF0000 到 0xFFFF0020 存储在虚拟内存中的 8 个 32 位指针，它大致对应于可以将我们从内核空间带到用户空间并返回的所有内容。

转换发生在以下不同的点：

-   发生硬件**重置**。这很明显：我们需要中止所有用户程序的执行，返回内核并使所有内容脱机。
-   遇到**未定义的指令**。如果发生这种情况，程序流将无法继续，内核必须对此执行某些操作。最典型的用途是实现某些硬件可能缺少的浮点算术指令的软件回退。在这种情况下，这些回退将由内核实现。（由于在内核中使用上下文切换和软件回退来执行此操作的成本很高，因此您通常只会使用编译器编译程序，该编译器首先将浮点指令替换为软件回退，但并不是每个人都拥有可用的源代码和构建环境，并且必须使用浮点指令运行预编译的二进制文件。
-   发生**软件中断**。这是用户空间应用程序向操作系统发出系统调用（主管调用）的最常见方式。如前所述，在 ARM32 上，这是由特殊的 **SVC**（又名 **SWI**）指令实现的，该指令将 1 字节参数传递给软件中断处理程序。
-   发生**预回迁中止**。当指令指针进入未分页内存时，就会发生这种情况，并且虚拟内存管理器 （mm） 需要在新的虚拟内存中分页才能继续执行。当然，这是一个内核任务。
-   发生**数据中止**。这与预回迁中止基本相同，但程序正在尝试访问未分页的数据，而不是未分页的指令。
-   发生**地址异常**。这在现代 ARM32 CPU 上不会发生，因为当 CPU 移出 Linux 不再支持的 ARM26 架构上的前 26 位地址空间时，情况除外。
-   **发生硬件中断** – 由于操作系统处理所有硬件，因此每当发生其中之一时，我们自然必须切换到内核上下文。ARM CPU 有两条硬件中断线：**IRQ** 和 **FIQ**。每个都可以路由到外部 _中断控制器_ ，最常见的是 GIC（全局中断控制器），特别是对于多核系统，但许多 ARM 系统使用自己定义的中断控制器。
-   **发生故障**，例如“除以零”或其他算术错误 - CPU 运行到未定义状态，并且不知道如何恢复和继续。这也称为 _处理器中止_ 。

内核和每个用户空间进程相对应的计算机程序必须在某个地方启动，然后在时间片中被打断，这意味着它们以某种方式被这些异常之一打断并被**抢占**，这个过程总是涉及从用户空间到内核空间的来回转换，然后再次回到用户空间。

那么这到底是怎么发生的呢？

### 调度第一个任务

所以我们知道 **schedule()** 在主 CPU 上被调用了一次，并且我们知道这会将内存管理上下文设置为第一个任务，设置程序计数器并执行它。这是最粗暴的进程调度方式，我们将详细介绍接下来会发生什么。

然而，我们必须着眼于内核抢占的宏观视角，才能全面了解这里发生的事情。

![[mk.att/Pasted image 20240605171552.png]]

_调度程序的心智模型：scheduler_tick() 设置标志TIF_NEED_RESCHED，稍后对 schedule() 的调用实际上会调用执行切换任务的 check_and_switch_context()。_

### 调度程序滴答声和TIF_NEED_RESCHED

作为在 **start_kernel()** 中启动内核的一部分，我们首先通过调用 **sched_init()** 来初始化调度程序，然后通过调用 **tick_init()** 来初始化系统滴答时钟，然后使用 **time_init()** 初始化计时器驱动程序。time_init() 调用将经历一些循环，最终初始化和注册系统的时钟源驱动程序，例如可以在 `drivers/clocksource` 中找到的驱动程序。

有时系统上的所有 CPU 都只能使用一个广播计时器（需要使用 IPC 中断将中断广播到所有 CPU），有时更复杂的架构会为每个 CPU 提供专用于计时器，因此每个内核都可以使用这些计时器来计划事件并驱动系统在该特定 CPU 上正常运行。

最合适的计时器也将作为clock event设备的一部分启动。但是，在 start_kernel() 中进一步调用 **local_irq_enable()** 之前，它的中断将无法触发。在此之后，系统将运行调度滴答。

由于调度在每个 CPU 上单独进行，因此调度程序计时器中断和重新调度调用也需要在每个 CPU 上单独完成。

clockevent 驱动程序可以提供周期性滴答，然后在适当数量的滴答后该进程将被中断；或者驱动程序只提供一次性中断（而非多个滴答，这称为 NO_HZ 的调度方式），然后它可以进一步计划事件，避免在任务运行时触发中断**只是为了滴答和切换到原本的任务**。

我们可以肯定的是，这个子系统总是为系统计划了一个新的滴答事件。如果使用周期性滴答，它可能会在 1/HZ 秒内发生；否则，当系统中有一段时间没有发生任何事件，它可以在几分钟后发生。

当 clockevent 最终以计时器中断的形式触发时，它会调用自己的 `->event_handler()` 这由 clockevent 子系统代码设置。当中断发生时，它将通过重复调用 **do_timer()** 然后调用 **scheduler_tick()** 来快进系统滴答。（我们通过不同的路径达到这一点，具体取决于是否启用了 HRTimers 和其他内核功能。

由于调用 scheduler_tick()，一些调度程序策略代码（如 deadline、CFS 等）将决定是否需要抢占当前任务，“重新调度”并在 CPU 的运行队列上调用 resched_curr(rq) (kernel/sched/core.c) 这反过来又会在当前任务上调用 set_tsk_need_resched(curr)， 将其标记为可以重新调度。

set_tsk_need_resched() 将为任务设置标志TIF_NEED_RESCHED。该标志被实现为特定于 arch 的位域，在 `arch/arm/include/asm/thread_info.h` 的 ARM32 案例中，ARM32 有一个名为 `_TIF_NEED_RESCHED` 的位掩码，汇编代码可以使用它通过逻辑 AND 操作快速检查它。

设置此位并不意味着新进程将立即开始执行。该标志在语义上的意思是“尽早方便，屈服于另一项任务”。因此，内核会等到找到合适的时机抢占任务，而这个时机就是调用 **schedule()** 的时候。

![[mk.att/进程调度与切换 2024-06-11 16.27.26.excalidraw]]

### 任务状态和堆栈

我们提到了特定于架构的结构体`thread_info`所以让我们详细讨论一下它的实际存储位置。这是一个比以前更简单的故事，因为如今，ARM32 thread_info只是task_struct的一部分。`struct task_struct` (include/linux/sched.h#demo37) 是 Linux 内核的通用部分，为特定任务保存的中央每个任务信息存储库，对于保持任务状态至关重要。下面是一个简化的视图，可让您了解它实际包含多少信息和指针：

```c
struct task_struct {
    struct thread_info thread_info;
    (...)
    unsigned int state;
    (...)
    void *stack;
    (...)
    struct mm_struct *mm;
    (...)
    pid_t pid;
    (...)
};
```

结构体`thread_info`在我们的例子中是 task_struct 的成员，它包含所有特定于体系结构方面的状态。

task_struct包含thread_info，也包含一个单独的内存`void *stack`，称为**任务堆栈**，这是任务在执行代码时存储其活动记录的地方。任务堆栈的大小为 THREAD_SIZE，通常为 8KB （2 * PAGE_SIZE）。如今，在大多数系统中，任务堆栈都映射到 VMALLOC 区域。

关于 ARM32，最后一段值得特别提及，因为情况发生了变化。Ard Biesheuvel 最近首先启用了 THREAD_INFO_IN_TASK (arch/arm/Kconfig)，使线程信息能够包含在task_struct中，然后为 ARM32 内核中的所有系统启用CONFIG_VMAP_STACK。这意味着 VMALLOC 内存区域用于映射和访问任务堆栈。出于安全原因，这是有好处的：任务堆栈是内核安全漏洞的常见目标，通过将其移动到 VMALLOC 区域，这只是一个巨大的虚拟内存地址区域，并用未映射的页面包围它，如果内核尝试访问当前任务堆栈之外的内存，这将导致页面冲突！

![[mk.att/Pasted image 20240606160614.png]]

_Linux 内核中的task_struct是内核保持有关特定任务（即特定处理上下文）的所有信息的连接的地方。它包含 .mm 内存上下文，其中所有虚拟内存映射都位于任务中。thread_info里面是cpu_context_save。它有一个大小为 THREAD_SIZE 的 ARM32 任务堆栈，通常是PAGE_SIZE两倍，即 8KB，周围环绕着未映射的内存以进行保护。同样，此内存映射到进程的内存上下文中。task_struct 和 thread_info 之间的划分是这样的，task_struct 是 Linux 通用的，thread_info是特定于体系结构的，它们一一对应。_

### 实际抢占

在我看来，当程序计数器（pc）实际上被设置为不同进程中的代码段时，就会发生抢占，这将在不同的时间点发生，具体取决于内核的配置方式。这是由于 **schedule()** 被调用而发生的，实质上是对架构的调用，用于切换内存管理上下文和活动任务。但是 schedule() 在何时何地被调用呢？

schedule() 可以调用有两个原因：

-   **自愿抢占**：例如，当内核线程想要放弃它的时间片时，因为它知道它暂时无法继续。对于您在内核中找到的此调用的大多数实例，都是这种情况。特殊情况是，当我们第一次启动内核并调用 **schedule_preempt_disabled()** 时，我们自愿抢占 PID 为 0 的 init 任务的内核执行，转而执行调度器中排队和优先排序的任何内容，这就是 _kthreadd_ 进程。其他地方可以通过对 **cond_resched()** 的调用，或者只是对 **schedule()** 的显式调用。
-   **强制抢占**：当任务被简单地调度出去时，就会发生这种情况。这种情况发生在内核线程和用户空间进程上。当进程用完其时间片并且 schedule_tick() 设置了TIF_NEED_RESCHED标志时，就会发生这种情况。我们在上一节中描述了如何从调度程序中设置此标志。

强制抢占发生的位置：

“强制抢占发生的位置”这个问题的简短答案是“**在异常处理程序的末尾**”。以下是详细信息。

抢占用户空间进程的最经典位置是 _系统调用的返回路径_ 。这发生在 `arch/arm/kernel/entry-common.S`中， 在 ret_slow_syscall() 和 ret_fast_syscall() 的汇编代码段中，其中 ARM32 内核在 `arch/arm/kernel/signal.c` 中显式调用 **do_work_pending()**(arch/arm/kernel/signal.c)。如果为线程设置了标志`_TIF_NEED_RESCHED`，这将发出对 **schedule()** 的调用，并且内核将处理下一个优先级任务的执行，无论它是用户空间还是内核空间任务。一种特殊情况是**ret_from_fork**这意味着新的用户空间进程已被fork，在大多情况下，父进程会立即被抢占，以支持通过此路径创建新子进程。

但是，抢占最常见的位置是从 _硬件中断返回_ 时。ARM32 上的中断在 `arch/arm/kernel/entry-armv.S` 中的汇编中处理。 带有一段程序集，将当前 CPU 的处理器状态保存到结构pt_regs中，然后从那里调用 `kernel/irq/handle.c` 中名为 **generic_handle_arch_irq()** 的通用中断处理代码。此代码被 ARM32 以外的其他架构使用，名义上只是将系统状态和寄存器存储在结构`pt_regs`记录中，并在退出时恢复它。但是，当 _generic_handle_arch_irq()_ 中的简单代码完成时，它会通过 `arch/arm/kernel/entry-common.S`  中的相同例程退出，作为快速或慢速系统调用。我们可以看到，在**ret_to_user_from_irq**中，代码将通过 `ldr r1， [tsk， #TI_FLAGS]` 显式检查 resched 和其他标志，并分支到执行 **do_work_pending()** 的处理程序，从而抢占另一个任务， _而不是_ 从中断返回。

现在学习 **do_work_pending()**：

```c
do_work_pending(struct pt_regs *regs, unsigned int thread_flags, int syscall)
{
        /*
         * The assembly code enters us with IRQs off, (...)
         */

        do {
                if (likely(thread_flags & _TIF_NEED_RESCHED)) {
                        schedule();
                } else {
                        (...)
                }
                local_irq_disable();
                thread_flags = read_thread_flags();
        } while (...);
        return 0;
}
```

请注意注释：我们进入 do_work_pending() 时禁用了本地 IRQ，因此我们不会被中断打断（但其他例外情况仍可能发生）。然后我们可能会调用 schedule()，另一个线程需要开始运行。当我们在安排另一个线程后返回时，我们应该在禁用中断的情况下继续退出异常处理程序，这就是为什么 if/else-clause 之后的第一条指令是 _local_irq_disable()_ – 我们可能已经从一个内核线程返回，它在启用中断的情况下正在愉快地执行。所以禁用中断。事实上，如果你研究过do_work_pending，你会发现这在其他具有类似设置的架构上看起来是一样的。

实际上 _do_work_pending()_ 比抢占还多做一些事情：它还处理进程和进程终止之间的信号等。但是对于这个流程，我们只需要知道它调用 schedule() 后跟着 local_irq_disable()。

结构体`pt_regs`应该被理解为“处理器跟踪寄存器”，这是另一个历史命名，很大程度上是因为它在跟踪（tracing）中的使用。在 ARM32 上，它实际上是 18 个 32 位字，代表特定任务的 CPU 的所有寄存器和状态位，即 _CPU 状态_，包括他编写了计数器 _PC_，这是任务应该恢复执行的地方， _除非_ 它被 schedule() 抢占。这样，如果我们抢占并留下任务，CPU 状态将包含我们需要知道的所有内容，以便从上次中断的地方继续。这些pt_regs在调用 _generic_handle_arch_irq()_ 期间存储在任务堆栈中。

`entry-common.S` 中的程序集可能有点难以理解，以下是我们在用户空间中执行时发生的中断返回路径的核心要素：

```c
	(...)
slow_work_pending:
	mov	r0, sp				@ 'regs'
	mov	r2, why				@ 'syscall'
	bl	do_work_pending
	cmp	r0, #0
	beq	no_work_pending
	(...)

ENTRY(ret_to_user_from_irq)
	ldr	r1, [tsk, #TI_FLAGS]
	movs	r1, r1, lsl #16
	bne	slow_work_pending
no_work_pending:
	asm_trace_hardirqs_on save = 0
	ct_user_enter save = 0
	restore_user_regs fast = 0, offset = 0
```

我们看到，当我们从 IRQ 返回时，我们检查线程中的标志，如果设置了任何位，我们会分支以执行慢速工作， 这是由 _do_work_pending()_ 完成的，它可能会调用 schedule()，然后返回，可能要晚得多，如果一切正常，则分支回 _no_work_pending_ 并恢复 UsersMode 寄存器并继续执行。

请注意，我们从这里返回的异常可能是**由 Linux clockevent 处理的计时器中断**，并通过调用 scheduler_tick() 来驱动调度！这意味着我们可以直接在定时器滴答触发的中断的返回路径上抢占。这样，**任务的时间片就尽可能精确**：scheduler_tick() 被计时器中断调用，如果它设置TIF_NEED_RESCHED，则不同的线程将在我们离开异常处理程序的时候开始执行！

**SVC/SWI 软件异常将采用相同的路径**，因此这些也将导致必要的重新调度。名为 `restore_user_regs` 的例程可以在 `entry-header.S` 中找到。 并且它几乎可以按照它所说的去做，以以下指令结束（如果我们忽略无关代码并假设慢路径）：

```c
	mov	r2, sp
	(...)
	ldmdb	r2, {r0 - lr}^			@ get calling r0 - lr
	add	sp, sp, #\offset + PT_REGS_SIZE
	movs	pc, lr				@ return & move spsr_svc into cp
```

r2 设置为堆栈指针，其中存储pt_regs，这些是 17 个寄存器和 CPSR（当前程序状态寄存器）。我们从堆栈中提取寄存器（包括被覆盖的 r2）——**注意**：`ldmdb` 指令后面的小插入符号 （**^**） 表示“也从堆栈加载 CPSR”——然后将堆栈指针移到保存的寄存器并返回。

使用异常作为抢占点是很自然的：异常的本质是用于在跳转到异常处理程序之前存储处理器状态，并且严格定义了如何将此状态存储到内存中，例如存储到每个任务的 _任务堆栈_ 中，以及如何在异常结束时可靠地还原它。因此，**这是做其他事情的好时机，例如切换到完全不同的进程**。

另请注意，这 _必须在_ 中断（异常）处理程序 _的末尾_ 发生。你可以想象，如果我们在中断的开头而不是结尾进行抢占，那么在具有电平触发中断的系统上会发生什么：我们将无法到达硬件中断处理程序，并且中断不会被清除。这违背了中断的原本意义，那么反过来呢？我们先处理异常，然后当中断处理程序完成时，我们可以选择在返回被中断的任务**之前**检查是否应该发生抢占。

但是，我们不要跳过 schedule() 的最后一部分。

### 设置程序计数器

因此，我们现在知道了系统可以抢占的几个地方，在 ARM32 上，我们看到这主要发生在名为 do_work_pending() 的函数中，它会为我们调用 schedule()。

调度程序 **schedule()** 调用应该非常快速地选择要运行的进程。最终，它会在 `kernel/sched/core.c` 中调用 **context_switch()**，这又会做两件事：

-   检查下一个任务是否具有唯一的内存管理上下文（`next->mm`不是 NULL），在这种情况下，将内存管理上下文切换到下一个任务。这意味着更新 MMU 以使用不同的 MMU 表。内核线程没有任何唯一的内存管理上下文，因此我们可以保留以前的上下文（内核虚拟内存映射到 ARM32 上的所有进程中，因此我们可以继续）。如果内存管理上下文确实需要切换，我们将调用 **switch_mm_irqs_off()** ，在 ARM32 的情况下，它只是定义为特定于 ARM32 的 **switch_mm()** （arch/arm/include/asm/mmu_context.h）它将调用特定于 ARM32 的 **check_and_switch_context()** (arch/arm/include/asm/mmu_context.h) — _请注意_，对于任何具有 MMU 的系统，此函数都隐藏在头文件中 — 这将执行以下两件事之一：
    -   如果禁用中断，我们将进行设置`mm->context.switch_pending = 1`，以便在稍后运行时**启用中断的情况下**进行内存管理上下文切换，因为如果在某些 VIVT（虚拟索引，虚拟标记）缓存类型上禁用中断，那么在 ARM32 上切换任务内存上下文的成本非常高，这又会导致这些系统上出现不可预测的 IRQ 延迟。这涉及某些 ARMv6 内核。在 schedule() 调用中禁用中断的原因是它将持有运行队列锁，这会禁用中断。就像代码中的注释所说的那样，这将在稍后特定于 arch 的 **finish_arch_post_lock_switch()** 中完成，该接口在下面实现，并在删除 runqueue 锁后立即调用。
    -   如果 _未_ 禁用中断，我们将立即调用 **cpu_switch_mm()**。这是一个per cpu 的回调函数，在汇编中为每个 CPU 在`arch/arm/mm/proc-NNNN.S`中编写为 **cpu_NNNN_switch_mm()** 。例如，所有 v7 CPU 的 cpu_v7_switch_mm() 都在 `arch/arm/mm/proc-v7.S`中。
-   通过调用 **switch_to()** 并将新任务和前一个任务作为参数，将上下文（例如寄存器状态和堆栈）切换到新任务。在大多数情况下，这绑定到特定于体系结构的 **__switch_to()**。在 ARM32 中，此例程是用汇编编写的，可以在 `arch/arm/kernel/entry-armv.S`中找到。

现在，最终的细节发生在 `__switch_to()` 中，它为当前任务和上一个任务提供了`thread_info`（即架构特定的状态）：

-   我们将当前任务的寄存器存储在任务堆栈中，在`struct thread_info` 的TI_CPU_SAVE索引处，该索引对应于结构体中的`.cpu_context`条目，该条目是一个 `struct cpu_context_save`，它包含 12 个 32-bit 值，用于存储 r4-r9、sl、fp、sp 和 pc。这是继续所需的一切，就好像我们在 schedule() 调用后“return”时 _什么都没发生_ 一样。我把“return”放在引号里，因为在我们真正回到那里之前，可能已经运行了大量的其他任务。您可能会问为什么不存储 r0、r1、r2 和 r3。这个问题将在后面解答。
-   然后获取 _新任务_ 的 TLS（线程本地存储）设置，并触发 switch_tls() (arch/arm/include/asm/tls.h)。在 v6 CPU 上，这具有特殊的含义，但在大多数情况下，我们最终会使用 _switch_tls_software()_ ，它将为任务设置 TLS 为0xffff0ff0。这是 内核提供的用户帮助程序 使用的虚拟内存中的硬编码值，而这些帮助程序又是用户空间 C 库使用的一些“类似于但不同于 VDSO”的内核例程。在支持线程 ID 寄存器 （TPIDRURO） 的 ARMv7 CPU 上，这将用于存储 `struct thread_info` 指针，因此它不能用于 ARMv7 上的 TLS。（稍后会详细介绍。）
-   然后，我们使用内核通知器链THREAD_NOTIFY_SWITCH。它们通常写成 “i C”，但从汇编代码段 `__switch_to()` 调用。一个值得注意的用例是，如果任务使用 VFP（矢量浮点单元），则 VFP 的状态将保存在此处，因此当任务恢复时也会干净地恢复。

然后我们到达 `__switch_to()` 的最后一步，这取决于我们是否配置了 CONFIG_VMAP_STACK。

_当我们不_ 使用 `VMAP：ed ` 堆栈时，简单的路径如下所示：

```c
	set_current r7, r8
	ldmia	r4, {r4 - sl, fp, sp, pc}	@ Load all regs saved previously
```

这里 r7 包含指向下一个任务的指针 thread_info（它将位于内核虚拟内存映射的某个地方），set_current() 将存储指向该任务的指针，以便 CPU 可以在任何时间点使用几条指令查找它。在较旧的非 SMP ARMv4 和 ARMv5 CPU 上，这只是标签 `__current` 指出的内存位置，但 ARMv7 和 SMP 系统有一个专用的特殊 CP15 `TPIDRURO` _线程 ID 寄存器_，用于将其存储在 CPU 中，以便可以 _非常_ 快速地找到thread_info。（毫不奇怪，此信息的唯一用户是 get_current() 程序集代码段，但它又是从 _许多_ 地方和上下文中调用的。）

下一个 `ldmia` 指令做了真正的技巧：它从 r4 指出的位置加载寄存器 r4 到 sl （r10）、fp （r11）、sp（r13） _和_ pc（r15），这又是结构thread_info中的`.cpu_context`条目，`struct cpu_context_save`，这是 _包括_ **pc** 在内的所有上下文，因此在此之后的下一条指令将是`struct cpu_context_save` 。我们已切换到新任务，抢占完成。

---

但是等一下。 r4 及以上所说，除某些寄存器外，那么 r0、r1、r2、r3、r12 （ip） 和 r14 （lr） 呢？我们切换到的任务不会错过这些寄存器吗？

对于 r0-r3，简短的回答是，当我们显式调用 schedule() 时（这只发生在内核内部），那么 r0 到 r3 是暂存寄存器，在任何函数调用期间都可以自由地“破坏”。因此，由于我们调用 schedule()，调用者应该准备好这些寄存器无论如何都会被破坏。状态寄存器 CPSR 也是如此。这是对内联程序集的函数调用，而不是例外。

即使我们在调用 schedule() 后环顾上下文，因为我们要么 （A） 开始一个全新的任务，要么 （B） 正在退出软件或硬件中断的异常处理程序，或者 （C） 在发生这种情况时显式调用 schedule()，这 _并不重要_。

然后 r12 是一个暂存寄存器，我们此时也没有使用 lr 调用堆栈（我们只是跳转到 pc！），因此这两个不需要保存或恢复。（在 ARM 或 VMAP 出口路径上，您会发现存在使用 ip 和 lr。）

当启动一个 _全新的_ 任务时，`struct cpu_context_save` 的所有内容都将为零，返回地址将设置为 **ret_from_fork** ，然后新任务将在用户空间中启动自己或作为内核线程。

如果我们在异常处理程序的出口路径上，我们调用各种 C 函数，r0 到 r3 用作暂存寄存器，这意味着它们的内容无关紧要。在异常结束时（这是，我们调用了 schedule() ），所有寄存器和 CPSR 都将从内核异常堆栈记录中恢复 pt_regs，然后异常无论如何都会返回，这是**使用异常处理程序作为抢占点**的另一个很好的理由。

这就是在` struct cpu_context_save`中缺少 r0 到 r3 的原因，不需要保留。

当调度器稍后决定调度再次中断的任务时，我们将 _在 schedule(); 调用后立即_ 返回执行。如果我们在 **do_work_pending()** 中退出异常回调函数，我们将继续从异常处理程序返回，并且对于该进程，它将“感觉”像是从硬件或软件中断返回的，并且执行将从那里继续进行，就像什么都没发生一样。

![[mk.att/进程调度与切换 2024-06-12 14.16.04.excalidraw]]

### 运行 _init_

那么 `/sbin/init` 实际上是如何执行的呢？

我们看到，_在start_kernel_ 之后，运行到 _rest_init_ ，它调用 `pid = user_mode_thread（kernel_init， NULL， CLONE_FS）` 创建了线程。

然后 _kernel_init_ 调用 _kernel_execve()_ 来执行 `/sbin/init`。它使用 ELF 解析器，以便在文件中读取和分页。然后它最终会调用 _start_thread()_ ，它将 `regs->ARM_cpsr = USR_MODE` 和 `regs->ARM_pc` 设置为可执行文件的起始地址。

然后，在调用 _schedule()_ 后，将选择此任务`task_struct`包括内存、上下文等。

但是，**每次对 schedule() 的调用都会在 schedule() 调用之后立即返回该点**，而用户空间任务被抢占用于调用 schedule() 的唯一位置是在异常处理程序中，例如当计时器中断发生时。好吧，这就是我们“作弊”的地方：

> 当我们在 `arch/arm/kernel/process.c` 中初始化进程时，我们将程序计数器设置为 **ret_from_fork**，**因此我们不会在任何 schedule() 调用后返回**：我们将返回到**ret_from_fork**！而这只是一个异常返回路径，因此这会将 `regs->ARM_cpsr` 恢复到 USR_MODE，并“从异常返回”到 `regs->ARM_pc` 中的任何内容，这是从 ELF 文件开始的二进制程序！

因此，`/sbin/init` 被执行是通过 ret_from_fork 从虚假异常返回的结果。从那时起，只有真正的异常，例如被 IRQ 打断，才会发生在该过程中。

这就是 ARM32 调度和执行进程的方式。

### 小结

实际发生调度：调用 **schedule()** 的时候。切换内存管理上下文和活动任务。

调度时机和类型：

| 调度路径            | 调度类型                 |
| ------------------- | ------------------------ |
| 开始一个全新的任务  | **自愿抢占**             |
| 显式调用 schedule() | **自愿抢占**             |
| 退出异常处理程序    | **强制抢占**：时间片耗尽 |

- pt_regs结构体
	- 18x32bit
	- 代表特定task的cpu所有寄存器和状态位，这是task应该恢复执行的地方

关于调度的内核流程可以参考[[系统调用]]，主动调度的发生依靠的就是系统调用，而被动调度则是在内核中返回用户空间时进行的。

- 在ARM32中，进程如何调度；
- 内核空间和用户空间是如何隔离以及切换；

| 切换方式 | 触发源     | 状态       |
| -------- | ---------- | ---------- |
| [[gic\|系统中断]] | 外设、调度 | 用户、内核 |
| [[系统调用]] | 用户触发   | 用户       |

> 参考文档
> [the-arm32-scheduling-and-kernelspace-userspace-boundary](https://people.kernel.org/linusw/the-arm32-scheduling-and-kernelspace-userspace-boundary)
