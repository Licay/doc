

[[learn_the_architecture_-_trustzone_for_aarch64_102418_0101_01_en.pdf]]
---v1.1

## 处理器中的TrustZone

### 切换到安全模式

如果当前进程在`NS.EL1`但是软件希望切换到`S.EL1`，该如何操作？

切入或切出安全状态都需要通过EL3，如图。

![[mk.att/Pasted image 20230711155259.png]]

按步骤描述图中的操作：
	1. 通过异常请求进入更高的运行等级。典型的就是FIQ或SMC(Secure Moniter Call)异常。稍后看更多的中断处理流程。
	2. 在适当的异常向量中进入EL3。软件就可以在EL3下切换`SCR_EL3.NS`位。
	3. 然后异常返回，将处理器从EL3切换到`S.EL1`。

更改安全状态不仅仅是在运行级别直接移动和更改`SCR_EL3.NS`位。我们还需要考虑处理器的状态。
向量寄存器、通用寄存器和大多数系统寄存器只有一个副本。当在安全状态间移动时，保存寄存器是软件的责任而不是硬件。按照惯例，这样的软件段被称位Secure Monitor。这使前面的示例看起来像下图。

![[mk.att/Pasted image 20230711162304.png]]

ATF是一个开源项目，提供了一个Secure Monitor的参考实现。在后面的指南中将讨论ATF。

安全态存储少量寄存器。这意味着寄存器有两个副本，并且核心自动使用属于当前安全状态的副本。这些寄存器包含处理器在任意状态下需要使用的所有寄存器。一个例子是`ICC_BPR1_EL1`，这是一个gic寄存器，用于控制中断调度。备份是特别要求的，而不是通用规则，而且在处理器的架构手册中明确使用。

当系统寄存器存在bank，我们用`(S)`和`(NS)`识所引用的那个。
例如 `ICC_BPR1_EL1 (S)` 和 `ICC_BPR1_EL1 (NS)`。

### 虚拟地址空间

本节中的内存管理指南介绍了多个虚拟地址空间和转换机制的概念。例如，对于EL0/1有一个翻译机制，如图。

![[mk.att/Pasted image 20230711170118.png]]

对于安全状态和非安全状态也有单独的翻泽机制。例如，一个安全的ELO/1翻泽机制和非安全的ELO/1翻泽机制，如下所示。

![[mk.att/Pasted image 20230711170419.png]]

在写地址时通常使用前缀来确定所指的翻译方式。

- `NS.EL1:0x8000` - 虚拟地址0x8000在非安全的EL0/1翻译方式。
- `S.EL1:0x8000` - 虚拟地址0x8000在安全的EL0/1翻译方式。

这是两种重要且独立的标记。核心不能在安全状态下使用非安全的翻译方式，反之亦然。

### 物理地址空间

处理两个安全状态外，该架构还做了物理地址空间的隔离。这意味着，在non-secure状态下只能访问non-secure资源。

![[mk.att/Pasted image 20230711172546.png]]

在secure状态下，软件可以访问secure和nono-secure的物理地址空间。翻译表中的NS位控制了虚拟内存块或page翻译为哪个物理地址空间，如下所示。

![[mk.att/Pasted image 20230711173030.png]]

与虚拟地址类似，通常使用前缀来标识所引用的地址空间。对于物理地址，前缀分别是NP和SP。
- `NP:0x8000` - 非安全物理地址空间中的地址0x8000
- `SP:0x8000` - 安全物理地址空间中的地址0x8000

最重要的是要记住，secure和non-secure是不同的地址空间，而不仅仅是可读或可写等属性。这意味着`NP:0x8000`和`SP:0x8000`是不同的内存位置，并且处理器会视为不同的内存位置。

如果实现了arm v9-A Realm Management Extension(REM)，物理地址空间的数量将增加到四个。有关REM的更多信息，参考《REM Guide》。

### 数据、指令和统一缓存

在ARM架构中数据缓存是使用物理标记。物理地址包括了该行所属的地址空间信息。

![[mk.att/Pasted image 20230712095455.png]]

当在`NP:0x800000`上进行缓存查找时，不会命中被标记为`SP:0x800000`的缓存。这是因为这是两个不同的地址。

这也会影响缓存维护操作。考虑前面图示中的数据缓存示例。如果虚拟地址va1映射到物理地址`0x800000`，那么当软件从非安全状态发出`DC IVAC, va1`（按虚拟地址进行数据或统一缓存行失效）指令时会发生什么？

答案是，在非安全状态下，所有地址都会转换为非安全的物理地址。因此，va1映射到`NP:0x800000`。缓存只针对包含指定地址的行进行处理，即`NP:0x800000`。包含`SP:0x800000`的行不受影响。

---
再次确认

如果在安全状态执行相同的操作，同时va1仍然映射到`NP:0x800000`，哪些缓存行会受影响？

和之前的例子一样，在安全状态下，缓存也会使包含指定物理地址`NP:0x800000`的行失效。

在非安全状态下，是否可以通过虚拟地址执行针对安全的缓存行操作呢？
不可以。在非安全状态下，虚拟地址只能映射到非安全的物理地址。根据定义，从非安全的缓存操作只能针对非安全行。

例如`DC ISW， Xt`，从非安全状态发出发操作只会影响包含非安全地址的行。而从安全状态下发出的操作会影响安全和非安全的行。

这意味着软件只能在安全状态下完全使整个缓存失效或清理。从安全状态在只能清理或失效非安全行。

### TLB

Transaction Lookaside Buffers (TLBs)是用于最近使用的地址转换表。处理器具有多个独立的转换机制。TLB记录的每个条目包括状态和转换机制。虽然TLB的结构是由具体实现定义的，如下图示例。

![[mk.att/Pasted image 20230712105025.png]]

当软件出EL1或EL2级别执行TLB失效操作（TLBI指令）时，软件针对当前的安全状态进行操作。因此，在安全状态下从EL1级别执行`TLBI ALLE1`操作会使所有S.EL0/1的TLB缓存失效。

EL3是一个特殊情况。正如在安全状态中提到的，当处于EL0/1/2级别时，SCR_EL3.NS比特控制处理器所处的安全状态。然而，EL3始终处于安全状态，不受SCR_EL3.NS比特的影响。当处于EL3级别时，SCR.EL3.NS允许软件控制TLBIs操作作用于哪个安全状态。

如，在EL3级别执行`TBLI ALLE1`：
- `SCR_EL3.NS==0`：影响安全的EL0/1转换机制
- `SCR_EL3.NS==1`：影响非安全的EL0/1转换机制

### SMC 异常

作为支持网个安全状态的一部分，体系结构中包括了Secure Monitor Call (SMC)指今。执行SMC指令会致SMC异常，该异常会定位到EL3级别。通常，SMC用于请求服务，可以是来自驻留在EL3的固件，也可以是由可信执行环境托管的服务。SMC首先被传递到EL3，在那里一个SMC调度程序确定将由哪个实体处理该调用。下图示展示了这个过程。

![[mk.att/Pasted image 20230712141912.png]]

为了标准化接口，Arm提供了SMC调用约定（DEN0028）和电源状态协调接口平台设计文档（DEN0022）。这些规范详细说明了如何使用SMC请求服务。

在EL1级别执行SMC时，可以将其捕获到EL2级别。这对于虚拟化监视器来说很有用，因为虚拟化监视器可能希望模拟虚拟机所看到的固件接口。

> 在任何安全状态下，SMC指令在EL0级别都不可用。

### 安全虚拟化

当Armv7-A引入虚拟化时，它只被添加到非安全状态。直到Armv8.3，Armv8同样适用于上述情况，如下图所示。

![[mk.att/Pasted image 20230712143102.png]]

如前所述，在安全状态下，EL3用于托管固件和安全监视器。安全的EL0/1用于托管可信执行环境（TEE），其中包括可信服务和内核。
在安全状态下，并没有迫切需要多个虚拟机。这意味着不需要支持虚拟化。随着TrustZone的采用增加，出现了几个需求：
- 一些受信任的服务与特定的受信任内核绑定。为了支持多个服务，可能需要运行多个受信任内核。
- 遵循以最低特权运行的原则，需要将某些固件功能移出EL3。

解决方案是在安全状态下引入对EL2的支持，这是从armv8.4-A开始支持的。

![[mk.att/Pasted image 20230712143547.png]]

与其说是一个完整的Hypenisor，S.EL2通常托管一个Sacure Parttion Manager (SPM)。SPM允许创建隔离的分区，这些分区无法看到其他分区的资源。一个系统可以有多个包含Trusted内核和具Trusted服务的分区。

也可以创建一个分区来容纳平台固件，这样就不需要在EL3级别运行该代码。
- 启用Secure EL2；
	当支持S.EL2时，可以启用或禁用它。是否启用S.EL2由SCR_EL3.EEL2位控制
	- 0：S.EL2禁用，行为如同不支持S.EL2的处理器。
	- 1：S.EL2启用。
- 安全状态下的第二阶段转换

> 1.IPA（Initial Program Analbysis）：IPA是指在虚拟化环境中进行程序分析和转换的过程。
> 2.PA（Physical Address）：PA是指物理她址，在虚拟化环境中表示实际硬件内存她址。

在安全状态下，虚拟机（VM）的第一阶段转换可以输出安全和非安全地址，并由翻译表描述符中的NS位控制。这导致两个IPA空间，安全和非安全，空间都有自己的第二阶段转换表。

![[mk.att/Pasted image 20230712145208.png]]

与第一阶段表不同，第二阶段表条目中没有NS位，对于给定的PA空词，所有的转换要么产生安全的物理地址，要么产生非安全的物理地址，这由一个寄存器位控制。通常，非安全的IPA转换为非安全的PA，安全的PA转换为安全的PA。

## 系统架构

到目前为止，在本指南中，我们集中关注了处理器，但是TrustZone远不止于一组处理器功能。为了充分利用TustZone的功能，我们还需要系统的其他部分提供支持。
以下是一个用TustZone的系统的示例。

![[mk.att/Pasted image 20230712151617.png]]

本节将探讨该系统中的关键组件及其在TrustZone中的作用。

### 外围设备和存储器

在前文的“物理她址空间”部分，我们介绍了两个物理地址空间的概念，即安全和非安全。处理器将正在访问的地址空间传递给内存系统。内存系统使用这些信息来实施隔离措施。

在本主题中，我们提到了安全总线和非安全总线。安全总线指的是对安全物理地址空间的总线访问，而非安全总线指的是对非安全物理地址空间的总线访问。请记住，在安全状态下，软件可以访问两个物理她址空间。这意味着总线访问的安全性不一定与生成该访问的处理器的安全状态相同。

> 在AMBA AXI和ACE中，`AxPROT[1]`信号用于指定正在被访问的地址空间。与翻译表中的NS位一样，0表示安全状态，1表示非安全状态。

理论上，一个系统可以拥有两个完全独立的内存系统，并使用访问的物理地址空间（AxPROT）来在它们之间进行选择。但在实践中，这种情况不大可能发生。相反，系统将物理地址空间用作属性，控制对内存系统中不同设备的访问。

一般而言，我们可以讨论两种类型的内存和外设以及总线完成器：
- 支持TrustZone的设备：
	这是一种具有一定的TrustZone知识并在内部使用访问安全性的设备。
	例如，通用中断控制器（GIC）。GIC可由安全状态和非安全状态下的软件进行访问。非安全访问仅能看到非安全中断，而安全访问可以看到所有中断。GIC利用总线事务的安全性来确定要呈现哪个视图。
- 不支持TrustZone的设备
	这代表了典型系统中的大多数完成器。该设备在内部不使用总线访问的安全性。
	例如，一个简单的外设，如定时器或片上内存。每个外设只能是安全的或非安全的，而不能在两者间切换。

### 强制隔离

TrustZone有时被称为完全强制保护系统。请求者发出访问安全信号，内存系统决定是否允许访问。如何进行基于内存系统的检查？

在大多数现代系统中，基于内存系统的检查是由互连机制完或的。例如，Arm NIC-400允许系统设计者为每个连接的传输器指定以下配置：
- Secure
	只有安全访问才会传递给设备，对于所有非安全访问，互连机制会生成故障，而不会将访问提交给设备。
- Non-secure
	只有非安全访问才会传递给设备。对于所有安全访问，互连机制会生成故障，而不会将访问提交给设备。
- 在引导时配置
	在引导时，系统初始化软件可以将设备配置为安全或非安全模式。默认情况下为安全模式。
- TustZone兼容
	互连机制允许所有访问通过。连接的设备必须实现隔离机制。

![[mk.att/Pasted image 20230712162825.png]]

这种方法对于具备TustZone识别的设备或完全存在于一个地址空间中的设备非常有效。对于较大的存储器，比如片外DDR存储器，我们可能希望将内存划分为安全区域和非安全区域。TrustZone地址空间控制器（TZASC）可以让我们实现这一点，如下图所示。

![[mk.att/Pasted image 20230712164559.png]]

TZASC类似于内存保护单元（MPU），它允许将设备的地址空询分割为多个区城，并指定每个区域为安全或非安全。用于控制TZASC的寄存器仅支持安全访问，只允许安全软件对内存进行分区。

一个例子是Arm TZC-400，它支持最多九个区域。

>片外存储器相对于片上存储器来说，安全性较低，因为攻击者更容易读取或修改其内容，片上存储器虽然更安全，但成本更高且容量有限。我们必须在成本、可用性和安全性之间进行平衡。在决定哪些数据放置在片外存储器中以及哪些数据需要保留在片上存储器中时要小心谨慎。

当实现了Amv9-A领域管理扩展（RME）时，内存可以通过粒度保护表在物理地址空间之间进行动态移动。有关更多信息，请参阅 Introducing Arms Dynamic TrustZone technology博客。

### 总线请求

![[mk.att/Pasted image 20230712170403.png]]

系统中的A型处理器具备TrustZore兼容，并在每次总线访问时发送正确的安全状态。然而，大多数现代SoC还包含非处理器总线请求设备，例如GPU和DMA控制器。

与完成设备一样，我们可以大致将系统中的请求设备分为几个组：
- TrustZone兼容设备
	部分请求设备具备Trustzone兼容，类似于处理器，它们在每次总线访问时提供适当的安全信息。其中的例子包括按照Arm SMMUv3规范构建的系统内存管理单元（SMMU）。
- 非TrustZone兼容设备
	并非所有请求设备都具备Trustzone兼容，特别是在重用传统IP时。这类请求设备通常在其总线访问中不提供安全信息或始终发送相同的值。
	非TrustZone兼容的请求设备需要访问哪些系统资源？根据对这个问题的回答，我们可以选择几种方法之一。
- 在设计阶段确定
	当请求设备只需要访问单个物理地址空间时，系统设计人员可以通过连接适当的信号来固定其访问的地址空间，这种解决方案简单，但缺乏灵活性。
- 可配置逻辑
	为请求设备的总线请问添加安全信息的逻辑，一些互连器。如Arm NIC-400，在启动时提供了一些客存器，安全软件可以使用这些寄存器来设置附加请求设备访问的安全性，这会要盖请求设备自身提供的任何值。这种方法仍然只允许请求设备访间单个物理地址空间，但比固定连接更灵活。
- SMMU
	更灵活的选择是使用SMMU。对于可信任的请求设备，SMMU的行为类似于安全状态下的MMU。这包括翻译表项中的NS位，用于控制访问哪个物理地址空间。

### M和R配置的Arm处理器

许多现代设计中同时包含A型、R型和M型处理器。例如，移动设备可能会配备一个A型处理器来运行移动操作系统，一个R型处理器用于蜂窝调制解调器，以及一个M型处理器用于低级系统控制。下图显示了一个示例移动设备以及可能找到的不同处理器。

![[mk.att/Pasted image 20230712192528.png]]

R型处理器不像A型处理器那样支持两个安全状志。这意味着在这些处理器上运行的软件无法控制输出的物理地址空间。从这个角度来看，它们的行为与其他非TrustZone兼容的总线请求设备类似。对于不实现Armv8-M的TustZone的M型处理器也是如此。

通常，这些处理器只需要访问单个物理地址空间。以移动设备为例，处理器通常包括一个用于低级系统控制的的M型处理器，有时被称为系统控制处理器（SCP）。在许多系统中，SCP将是一个仅安全的设备。这意味着它只需要能够生成安全访问的处理能力。

### 中断

下面将介绍中断系统，如你所见。

![[mk.att/Pasted image 20230713095047.png]]

通用中断控制器（GIC）支持TrustZone。每个中断源在GIC规范中称为INTID，并被分配给三个组之一：
- Group0：安全中断，作为FIQ信号；
- 安全Group1：安全中断，作为IRQ或FIQ信号；
- 非安全Group1：非安全中断，作为IRQ或FIQ信号。

这由软牛写入`GIC[DIR]_IGROUPR<n>`和`GIC[DIR]_IGRPMODR<n>`寄存器来控制，只能在安全状态下执行。分配不是静态的，软件可以在运行时更新分配。

对于配置为安全的INTIDs，只有总线安全访问可以修改状态和配置。对于与安全中断对应的寄存器字段，在非安全总线访问中读取为0。

对于配置为非安全的INTIDs，无论是安全还是非安全总线访问都可以修改状态和配置。

为什么会有两个安全组？通常，GroupO用于由EL3固件处理的中断，这些中断与低级系统管理功能相关。安全Group1用于所有其他安全中断源，并目通常由S.EL1或S.EL2处理。

### 中断捕获

处理器有两个异常中断，IRQ和FIQ当一个中断变为挂起状态时，GIC根据中断的组别和处理器的当前安全状态使用不同的中断信号：
- Group0中断
	- 总是使用FIQ异常信号
- 安全Group1
	- 处理器当前处于安全状态-使用IRQ异常信号
	- 处理器当前处于非安全状态-使用FIQ异常信号
- 非安全Group1
	- 处理器当前处于安全状态·使用FIQ异常信号
	- 处理器当前处于非安全状态·使用IRQ异常信号

请记住，Grop0中断通常用于EL3固件。这意味着：
- IRQ表示当前安全状态下的Group1中断。
- FIQ表示我们需要进入EL3，无论是为了切换安全状态还是让固件处理中断。

以下示例显示了如何配置异常路由控制：

![[mk.att/Pasted image 20230713104047.png]]

上图显示了一种可能的配置。另一个常见的选项是在安全状态下将FIQ路由到EL1。可信0S将FIQ视为一种让步请求，可以让固件或非安全状态处理。这种中断路由的方法使得可信OS有机会以受控方式退出。

### 调试、跟踪和分析

下面将看到系统中的调试和跟踪组件，如你所见。

![[mk.att/Pasted image 20230713111300.png]]

现代Arm系统拥有广泛的调试和性能分析功能。而在TrustZone下，我们必须确保这些功能不能被用于危害系统安全。

就调试功能而言，考虑到开发新的SoC芯片，不同的开发人员被信任来调试系统的不同部分。芯片公司的工程师应该被信任，因为他们需要调试所有部分，包括secure状态的代码。为此，应该启用所有的调试功能。

当芯片交付给OEM时，他们仍然需要调试非安全状态的软件栈。但是，可能会限制OEM调试安全状态的代码。

在包含芯片的产品中，我们可能希望为应用程序开发人员提供一些调试功能。但我们也希望限制芯片提供商和OEM的代码调试能力。

为了应对这种情况，我们可以使用不同的调试、追踪和性能分析功功能的信号来进行控制。这包括用于控制在安全状态和非安全状态下使用这些功能的的单独信号。

以调试为例，这些信号包括：
- DBGEN-顶层侵入式调试使能，控制安全状态和非安全状态下的外部调试；
- SPIDEN-安全侵入式调试使能，控制在安全状态下进行外部调试的能力。

> 这两个信号只是示例。还有其他调试身份验证信号。请参考您的处理器手册以获取完整的列表。

以下是如何使用这些管号的示例：
- 芯片设计者进行早期开发
	- `DGBEN==1`和`SPIDEN==1`，启用完全的外部调试
- OEM进行产品开发
	- `DBGEN==1`，启用非安全状态下的外部调试
	- `SPIDEN==0`，禁用安全状态下的通试
- 出货产品
	- `DGBEN==0`和`SPIDEN==0`，禁用安全状态和非安全状态下的外部周试
	- 应用程序调试仍然是可能的

由于我们希望在不同的开发阶段使用不同的信号值以对应用进行开发，通常会使用e-fuses或认证模块来连接这些信号，以下是示例。

![[mk.att/Pasted image 20230713135825.png]]

通过在制造过程中烧断保险丝，可以永久禁用外部调试功能。使用保险丝确实会让现场调试变得更加困难。一定保险丝被烧断，就无法恢复。如果使用认证模块会更加灵活。

### 其他设备

最后，我们将讨论系统中的其他设备，如你所见。

![[mk.att/Pasted image 20230713142050.png]]

在示例中TrustZone启用系统包括一些尚未涵盖但在构建实际系统中需要的设备
- 一次可编程存储器（OTP）或保险丝
	这些是一旦写入就无法更改的存储器，与每个芯片上都包含相同镜像的引导ROM不同，OTP可以编程为设备谁一值和可能的OEM唯一值。
	OTP中存储的一项内容是设备唯一的私钥。每个芯片制造时，将一个随机生成的唯一密钥写入OTP。这个设备唯一私钥用于将数据关联到芯片上。
	设备唯一私钥的优点是防止了类攻击。如果每个芯片都有相同的密钥，那么如果一个设备受到威助，所有类似的设备也会容易受攻击。
	OTP通常还用于存储QEM公钥的哈希值。与其他存储器相比，OTP的成本相对较高。对于公钥，只存储哈希而不是完整密钥可以节首成本。
- 非易失性计数器
	非易失性（NV）计数器，可能类似于更多的保险丝实现。这是一个只能增加而不能重置的计数器。
	NV计数器用于防止回滚攻击。想象一下，某个设备的固件版本3中存在已知漏洞。设备当前运行的版本是4，修复了漏洞的固件版本。攻击者可能尝试将固件降级回版本3，以利用已知漏洞，为了防止这种情况，每次更新固件时，计数器都会增加。在引导时，固件版本将与NV计数器进行比对。如果不匹配，设备就知道正在受到攻击。
- 可信RAM和可信ROM
	这些是芯片上的仅限安全访问的存储器。
	可信ROM是从中提取第一个引导代码的地方，处于芯片内部意味着攻击者无法替换它。作为只读存储器，攻击者也无法重新编程它。这意味着我们有一个已知、可信的执行起点，在本指南的软件架构部分将进行讨论。
	可信RAM通常是几百千字节的静态随机存取存储器（SRAM）。这是运行在安全状态的软件的工作内存。同样，由于它位于芯片上，攻击者很难获取其中的内容。

### 可信的基础系统架构

可信基础系统架构（TBSA）是Arm为系统设计师提供的一套指南。TBSA提供了关于不同用例所需资源的建议，例如需要多少bit的OTP。

## 软件架构

在[[#处理器中的TrustZone]]和[[#系统架构]]中，我们讨论了硬件中的TrustZone支持，包括Arm处理器和更大范围的存储系统。本节将介绍TrustZone系统中的软件架构。

### 顶层软件架构

下图显示了一个启用了TrustZone的系统的典型软件堆栈。

![[mk.att/Pasted image 20230713145517.png]]

> 为了简化起见，图中没有包含虚拟机监控程序，尽管它们可能存在。

安全状态下的可信内核承载着诸如密钥管理或数字版权管理等服务。在非安全状态下运行的软件需要对这些服务进行受控访问。

用户空间应用程序不大可能直接意识到TrustZone的存在，相反，它会使用由用户空间库提供的高级API。该库负责与可信服务进行通信。这类似于图形API提供对底层GPU的抽象。
服务库与可信服务之间的通信通常使用内存中的消息队列或邮箱来处理。有时会使用“World shared Memory”（WSM）一词来描述用于此通信的内存。这些队列必须位于两类软件都能看到的内存中，也就是非安全内存。因为非安全状态只能看到非安全内存。

服务库将请求或多个请求放入邮箱中，然后调用内核空间中的驱动程序。驱动程序负责与受信任执行环境（TEE）进行低级交互，其中可能包括为消息队列分配内存并向TEE注册它们。请记住，这两个世界运行在不同的虚拟地址空间中，因此它们不能使用虚拟地址进行通信。

驱动程序通常使用SMC来调用安全状态，并通过EL3安全监视器传递到TEE中的可信内核。内核调用请求的服务，然后可以从队列中读取请求。

### 可信消息

在我们刚刚描述的流程中，请求位于非安全状态内存中的队列中，如果出现以下情况会怎样呢：
- 发出初始请求的应用程序是恶意的？
- 其他恶意软件替代了队列中的消息？

TEE必须假定来自非安全状态的任何请求或数据都可能是恶意的或被其他方式篡改。这意味着身份验证请求或请求者必须在安全状态下完成。具体的实现取决于所提供的受信任服务及其安全要求，没有唯一的答案。

### 调度

在TrustZone系统中，有两个软件栈，一个用于非安全状态，另一个用于安全状态。处理器核心一次只能处于一种状态。那么是谁决定每个世界何时运行？

对EL3固件的显式调用，如使用Power State Coordination Interface（PSCD）进行的电源管理请求，通常是阻塞的。这意味着只有在请求的操作完成后才会将控制权返回给非安全状态。然而，这些调用往往很短且不频案。

TEE通常在非安全状态操作系统调度程序的控制下运行，一个可能的设计是在操作系统下运行一个守护进程作为TEE的占位符。当操作系统调度守护进程时，它通过SMIC将控制权交给TEE。然后TEE运行，并处理未完成的请求，直到下一次调度时钟或中断。然后控制权返回给非安全状态操作系统。

这可能看起来很奇怪，因为这种方法使得不受信任的软件可以控制受信任软件的执行时间，这可能会导致“拒绝服务”攻击。然而，因为TEE为非安全状态提供服务，阻止其运行只会导致这些服务不可用。例如，攻击者可能会阻止用户观看DRM保护的视频，这种攻击不会泄露任何信息。这种设计可以确保机密性，但无法保证可用性。

我们可以设计软件栈以提供可用性。GIC允许安全中断比非安全中断具有更高的优先级，防止非安全状态阻止安全中断。

### OP-TEE

有许多可信内核，包括商业和开源的。一个例子是OP-TEE，最初由ST-Ericsson开发，但现在是由Linaro托管的开源项目。OP-TEE提供了一个功能齐全的可信执行环境，你可以在OP-TEE项目网站上找到详细描述。

OP-TEE的结构如下图所示：

![[mk.att/Pasted image 20230713160524.png]]

OP-TEE内核在S.EL1中运行，在S.EL0中托管可信应用程序。可信应用程序通过TEE内部API与OP-TEE内核进行通信，TEE内部API是由Global Platform组织开发的标准API。Global Platform致力于开发标准API，许多不同的TEE支持这些API，不仅仅是OP-TEE。

> 在前面的图表中，可信应用程字没有显示为OP-TEE的组件。这是因为它们不是核心OP-TEE操作系统的一部分。OP-TEE项目确实提供了一些示例可信应用程序供人们进行实验。

在非安全状态下，内核空间中有一个低级别的OP-TEE驱动程序。它负责处理与OP-TEE内核的低级通信。

在非安全用户空间（EL0）中，有一个实现Global Platiom API的用户空间库，TEE客户端API是应用程序用来访问可信应用程序或服务的接口。在大多数情况下，我们不希望应用程序直接使用TEE客户端API，而是会有另一个特定于服务的库提供更高级别的接口。

OP-TEE还包括一个称为tee-supplicant的组件。tee-supplicant处理由OP-TEE支持的服务，这些服务需要一定程度的rich OS交互。一个例子是安全存储。

### 与非安全虚拟化的交互

在我们目前介绍的示例中，我们忽略了非安全状态下可能存在的虚拟化监控程序。当存在虚拟化监控程序时，虚拟机与安全状态之间的许多通信将通过虚拟化监控程序进行。

例如，虚拟化环境中，使用SMC （Secure Monitor Call）来访问固件功能和可信服务。固件功能包括诸如电源管理之类的功能，虚拟化监控程序通常不希望虚拟机直接访问这些功能。

虚拟化监控程序可以截获来自EL1的SMC，以便检查请求是用于固件服务还是可信服务。如果请求是用于固件服务，虚拟化监控程序可以模拟接口而不是转发调用。虚拟化监控程序可以将可信服务请求转发到EL3。您可以在下面的图表中看到这一点。

![[mk.att/Pasted image 20230713163043.png]]

### 引导流和信任链

引导是任何TrustZone系统的关键部分，只有在引导流程中所有先前运行的软件组件都可信时，才能信任某个软件组件。这通常被称为信任链。下图显示了一个简化的信任链。

![[mk.att/Pasted image 20230713165238.png]]

在我们的示例中，第一个运行的代码是引导ROM。我们必须隐式地信任引导ROM，因为没有早期的引导阶段来验证具内容。处于ROM中可以保护初始引导码免受改写，将初始引导码保留在芯片上可以防止其被替换，因此我们可以隐式地信任它。引导ROM代码通常很小且简单。其主要功能是从闪存中加载和验证第二阶段的引导代码。

第二阶段的引导代码执行平台的系统初始化，例如设置用于片外DRAM的内存控制器。该代码还负责加载和验证将在安全状态和非安全状态下运行的映像。例如，在安全状态下加载TEE，在非安全状态下加载像UEFI这样的高级固件。

之前，我们介绍了系统控制处理器（SCP）。SCP是许多现代SoC中执行低级系统控制的微控制器，当存在SCP或类似组件时，它也构成了信任链的一部分。下图显示了这一点。

> 官方的图错了？？

![[mk.att/Pasted image 20230713165238.png]]

### 引导失败

在可信引导系统中，每个组件在加载之前都会验证下一个组件，形成一个信任链。现在让我们看看当验证失败时会发生什么情况。

对于这种情况，没有一个固定的答案。它取决于系统的安全需求以及引导处理器的哪个阶段发生故障。以移动设备上的SoC为例。如果验证失败发生在以下阶段：

- 第二阶段引导映像
	第二阶段引导映像对于SoC和理器的初始化是必需的。如果在此阶段证失败，我们可能无法确定设备是否能安全后动和正常运行。因此，如果在此阶段验证失败，通常是致命的，设备将无法启动。
- 可信执行环境（TEE）
	TEE提供诸如密钥管理之类的服务。即使在没有TEE的情况下，设备仍然可以在有限的级别上运行，因此，我们可以选择不加载TEE，但仍允许非安全状态软件加载。
- 非安全状态固件或Rich-OS映像
	非安全状态软件已经处于较低的信任级别。我们可以选择允许其启动，但阻止通过TEE提供的高级功能的访问。例如，一个基于Trustzone的DRM可能在不受信任的操作系统映像中不可用。

这些只是示例，每个系统都需要根据其安全需求做出自己的决策。

### 可信板级引导需求

之前我们介绍了可信基础系统架构（TBSA），他是对系统设计者的指导。可信板级引导需求（TBBR）则是一组类似的指南，专为软件开发者而设计。TBBR提供了在支持TrustZone的系统中如何构建可信引导流程的指导。

### 可信固件

可信固件是用于Armv8-A设备的安全世界软件的开源参考实现。可信固件为SoC开发者和OEM厂商提供了一个符合相关Arm规范（包话TBBR和SMCC）的参考可信代码库。

以下是可信固件的结构的示意图。

![[mk.att/Pasted image 20230713193015.png]]

SMC调度程序处理传入的SMC请求。它会确定哪些SMC请求应该由可信固件在EL3处理，以及哪些SMC请求应该转发到可信执行环境。

可信固件提供了处理Arm系统IP（如互联）的代码。ic提供商需要提供处理定制或第三方IP的代码。这包括SoC特定的功耗管理功能。

## 使用实例

在处理器和系统架的TrustZone中，我们介绍了硬件中的TrustZone功能，并过论了使用这些功能的典型软件堆栈。在这个主题中让我们整合这些知识，看一些示例用例。

### 加密文件系统

移动设备，如智能手机，包含许多个人数据。如果设备丢失或被盗，用户关心这些数据的机密性。这就是为什么大多数最新设备支持文件系统加密。可信区域可以作为保护这些数据的解决方案的一部分使用。

外部闪存中存储的数据是加密的。在启动过程中，设备对用户进行身份验证，然后提供用于解密文件系统的密钥。解密可能由处理器处理，或者集成到闪存控制器中。

文件系统的密钥也需要保护其机密性。如果密钥被攻击者获得，他们就可以解密文件系统。

身份验证后的流程如下图所示。

![[mk.att/Pasted image 20230713194835.png]]

在安全状态下：
- 身份验证后，加密的文件系统密钥被读入芯片上的安全内存中。使用存储在芯片上的请求设备唯一密钥对文件系统密钥进行解密和检查。
- 文件系统密钥被配置到加密引擎或内存控制器中的保护性访问寄存器中。对闪存中文件系统的后续总线访问将使用配置的密钥进行加密或解密。
- 通过在安全状态下执行这些操作，Trustzone允许我们永远不将文件系统密钥暴露给非安全状态的软件。这意味着非安全状态中的恶意代码无法提取这些密钥以供后续攻击使用。根据我们目前讨论的内容，思考以下问题：

为什么文件系统密钥存储在芯片外部？
与芯片内存相比，芯片外部存储器容量有限且更昂贵。将文件系统密钥存储在芯片外部可以降低成本。通过加密密钥，我们确保了机密性。存在恶意软件可能破坏密钥的风险，这可能失去完整性，但不会暴露数据。

为什么在这个示例中我们使用单独的文件系统密钥，而不是请求设备的唯一私钥？
理论上，我们可以使用设备的唯一密钥。但这意味着我们无法更改密钥，因为请求设备的唯一私钥存储在OTP中。例如我们出售手机，那可能会成为一个问题。相反，我们生成一个新的随机文件系统密钥。如果你想要格式化或重置设备，我们可以删除文件系统密钥并生成一个新的密钥。使用旧密钥加密的任何数据现在都无法恢复。

### 空中固件更新

第二个例子涉及到更新引导固件。我们系统的要求如下：
- 新的固件镜像通过网络提供。
- 只有验证过的镜像才能安装。
- 固件版本不能回滚。

为了实现这些目标，原始设备制造商（OEM）使用其私钥对镜像进行签名。下载设备配备了可以用来验证签名的公钥。当固件更新时，非易失性计数器递增，以便可以检测到回滚操作。

我们的系统如下图所示：

![[mk.att/Pasted image 20230714100858.png]]

镜像的下载是在非安全状态下进行的。镜像本身不是机密信息，因此我们不需要保护其机密性。下载的镜像被放置在内存中，并向安全状态发出安装请求。

安全状态的软件负责身份验证。它使用原始设备制造商（OEM）的公钥进行身份验证，该公钥通常存储在芯片外的闪存中。这个密钥不是机密信息，因此我们不需要确保其机密性。我们需要确保密钥的真实性并检测替换密钥的尝试。为了实现这一点，我们在芯片上保存密钥的哈希值，可以在需要时用于检查密钥。哈希值使用更少的比特，而且芯片上的存储器是昂贵的。

当加载并验证了公钥后，可以对新的固件镜像进行验证。我们希望确保它是真实的（签名匹配），并且它是比当前已安装的固件版本更新的版本。

假设这些检查通过，镜像将被安装，并且非易失性计数器递增。递增非易失性计数器意味着，如果攻击者试图安装旧的固件，设备将检测到该尝试。

在这个示例中，Trustzone允许我们确保用于验证固件镜像的密钥得到保护，并目固件镜像无法回滚。

## 确认你的知识

以下问题将帮助你检查知识点。

什么是Arm架构中的安全状态和物理地址空间？
Arm架构中的安全状态是安全状态（Secure state）和非安全状态（Non-secure state）。
Arm架构中的物理地址空间是安全物理地址空间（Secure physical address space）和非
安全物理地址空间（Non-secure physical address space）。

在每个异常级别中，什么确定处理器处于安全状态还是非安全状态？
对于ELO/1/2，是通过`SCR_EL3.NS`位来确定的。EL3始终处于安全状态。

在非安全状态下，软件能否访问安全物理地址空间？
不可以。在非安全状态下，虚拟地址总是映射到非安全物理地址。

访问`SP:0x80000`是否会命中包含`NP:0x80000`的缓存行？
不会。`SP:0x80000`和`NP:0x80000`是不同的位置，因此不会发生缓存命中。

Trusted Base System Architecture (TBSA）和Trusted Board Boot Requirements
（TBBR）提供了哪方面的指导？
TBBR提供引导方面的指导，而TBSA提供系统架构方面的指导。

TrustZone Address Space Controller（TZASC）的目的是什么？
TZASC允许将内存划分为安全区域和非安全区域。

## 相关信息

以下是与本指南相关的一些资源：

- [Arm架构和参考手册](https://developer.arm.com/docs)：查找与本指南和其他类似主题相关的技术手册和文档。
- [Arm社区](https://community.arm.com/?_ga=2.233110551.86978151.1648720643-1382752381.1648720643)：提出开发问题，并从Arm专家那里找到特定主题的文章和博客。
- 要了解更多关于安全虚拟化的信息，请参阅我们的白皮书[《在安全世界中使用虚拟化进行隔离》](https://developer.arm.com/-/media/Files/pdf/Isolation_using_virtualization_in_the_Secure_World_Whitepaper.pdf?revision=23668ea4-3b8b-4095-b03e-7356fa6b1e69&la=en&hash=534D1D04207478F1CDE71CF7D56DEDFF4030E8E0)。
- [Arm CoreLink通用中断控制器v3和v4指南](https://developer.arm.com/utility/404?item=web%3a%7b485F9F64-57B7-4D95-9B4D-86A80052AE58%7d%40en)
- [硅IP安全性](https://www.arm.com/products/silicon-ip-security?_ga=2.266530823.86978151.1648720643-1382752381.1648720643)：在此处找到有关Trusted Base System Architecture的更多信息。
- [Cortex-A的TrustZone](https://developer.arm.com/ip-products/security-ip/trustzone/trustzone-for-cortex-a)
- [Cortex-M的TrustZone](https://www.arm.com/why-arm/technologies/trustzone-for-cortex-m?_ga=2.203560985.86978151.1648720643-1382752381.1648720643)
- [介绍Arm动态TrustZone技术](https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/introducing-arms-dynamic-trustzone-technology?_ga=2.203560985.86978151.1648720643-1382752381.1648720643)

以下是与本指南中的主题相关的一些资源：

**OP-TEE**

- [OP-TEE](https://www.op-tee.org/)是可信执行环境的一个示例。
- OP-TEE是一个开源项目。OP-TEE实现了由全球平台组织开发和维护的行业标准API。有关这些API的信息，请参阅[全球平台规范库](https://globalplatform.org/specs-library/?filter-committee=tee)。
- 您可以在免费的Arm Foundation模型或Arm Development Studio提供的FVP模型上尝试使用Trusted Firmware和OP-TEE。有关构建和运行[Arm参考平台](https://community.arm.com/dev-platforms/w/docs/304/arm-reference-platforms-deliverables?_ga=2.237245193.86978151.1648720643-1382752381.1648720643)的更多信息，请参阅相关文档。

**SMC异常**

以下规范描述了如何使用SMC请求服务：

- [SMC调用约定（DEN0028）](https://developer.arm.com/architectures/system-architectures/software-standards/smccc)
- [电源状态协调接口规范（DEN002）](https://developer.arm.com/architectures/system-architectures/software-standards/psci)

**受信任的板级启动要求**

- [Trusted Board Boot要求](https://developer.arm.com/documentation/den0006/d)：关于如何在启用TrustZone的系统中构建受信任的引导流程的指导。

**受信任的固件**

- [Trusted Firmware](https://www.trustedfirmware.org/)：找到一些处理Arm System IP（如互连）的示例代码。

## 下一步

本指南介绍了TrustZone安全架构，该架构在两个世界或执行环境之间提供隔离。Arm架构还具有在给定环境中提供强大安全性的功能。要了解更多信息，请阅读我们的[《安全指南-为复杂软件提供保护》](https://developer.arm.com/architectures/learn-the-architecture/providing-protection-for-complex-software)。

在本指南中，我们提到了虚拟化和GIC（通用中断控制器）的主题，但没有对其进行详细探讨。要了解更多关于这些主题的内容，请阅读我们系列指南中的以下内容：

- [Arm CoreLink通用中断控制器v3和v4指南](https://developer.arm.com/utility/404?item=web%3a%7b485F9F64-57B7-4D95-9B4D-86A80052AE58%7d%40en)
- [AArch64虚拟化](https://developer.arm.com/documentation/107627/latest)
- 本指南不涵盖Armv9-A Realm Management Extension（RME）。有关RME的更多信息，请参阅[Realm Management Extension](https://developer.arm.com/documentation/den0126/latest)指南。
